# 进程和线程

## 考点总结

- 调度算法的评价指标
  - 理解并且会计算



![image-20230801172212199](./assets/image-20230801172212199.png)

- 要会自己定义记录型信号量
- 但如果题目中没特别说明，可以把信号量的声明简写成这种形式



![image-20230801175516957](./assets/image-20230801175516957.png)

- 大题

## 知识总结

![image-20230729205341824](./assets/image-20230729205341824.png)

![image-20230729213510373](./assets/image-20230729213510373.png)

![image-20230729224351508](./assets/image-20230729224351508.png)

![image-20230730215529834](./assets/image-20230730215529834.png)

![image-20230730224910575](./assets/image-20230730224910575.png)

![image-20230731144758529](./assets/image-20230731144758529.png)

![image-20230731150253815](./assets/image-20230731150253815.png)

![image-20230731152614700](./assets/image-20230731152614700.png)

![image-20230731161403740](./assets/image-20230731161403740.png)

![image-20230731165604684](./assets/image-20230731165604684.png)

![image-20230731181244842](./assets/image-20230731181244842.png)

![image-20230731210756707](./assets/image-20230731210756707.png)

![image-20230731215701874](./assets/image-20230731215701874.png)

![image-20230731225055140](./assets/image-20230731225055140.png)

![image-20230801144041257](./assets/image-20230801144041257.png)

![image-20230801170800592](./assets/image-20230801170800592.png)

![image-20230801175506143](./assets/image-20230801175506143.png)

![image-20230801201649385](./assets/image-20230801201649385.png)

![image-20230801204833197](./assets/image-20230801204833197.png)
![image-20230801204844852](./assets/image-20230801204844852.png)

![image-20230801211559705](./assets/image-20230801211559705.png)

![image-20230801215900722](./assets/image-20230801215900722.png)

![image-20230801223933484](./assets/image-20230801223933484.png)

![image-20230802153419487](./assets/image-20230802153419487.png)

![image-20230809153311455](./assets/image-20230809153311455.png)

![image-20230809160208718](./assets/image-20230809160208718.png)

![image-20230809165535329](./assets/image-20230809165535329.png)

![image-20230809170241971](./assets/image-20230809170241971.png)



## 知识滚雪球：程序是如何运行的

![image-20230729203811979](./assets/image-20230729203811979.png)

![image-20230729203823777](./assets/image-20230729203823777.png)

![image-20230729223642916](./assets/image-20230729223642916.png)

![image-20230729223653958](./assets/image-20230729223653958.png)

![image-20230729224229544](./assets/image-20230729224229544.png)

![image-20230731160323649](./assets/image-20230731160323649.png)

- 程序是如何运行的
  - C 语言代码经过编译器翻译编程二进制的机器指令
    - 一条高级语言的代码翻译过来可能会对应多条机器指令
    - 存放指令序列的就是可执行文件（*.exe）
  - 程序在等待运行之前要先放在外存中的作业后备队列，等待被服务（调度）
  - 程序运行之前要把可执行文件放入内存当中（高级调度/作业调度）
    - 创建对应的进程，也就是要创建相应的 **PCB**
    - 内存中会有一串串包含程序指令的**程序段**
    - 还有包含运行过程中产生的各种数据的**数据段**（变量）
  - CPU 从内存中取出指令（进程调度）
    - CPU 中会设置很多寄存器，用来存放程序运行过程中所需的某些数据
      - PSW：程序状态字寄存器
      - PC：程序计数器，存放下一条指令的地址
      - IR：指令寄存器，存放当前正在执行的指令
      - 通用寄存器：其他一些必要信息
    - 指令顺序执行的过程中，很多中间结果是放在各种寄存器中的
      - 这些寄存器并不是进程独属的，其他进程上 CPU 也会使用这些寄存器
      - 思考：执行完指令后，另一个进程开始上 CPU 运行
        - 另一个指令在运行过程中也会使用各个寄存器，之前指令的寄存器的中间结果就会被覆盖
      - 解决方法：在进程切换时先**在 PCB 中保存这个进程的运行环境**（保存一些必要的寄存器信息）
        - PSW：xxxxxxx
        - PC：指令 4 的地址
        - 通用寄存器：2
      - 当原来的进程再次投入运行时，可以通过 PCB 恢复它的运行环境
- 程序运行的过程其实就是 CPU 执行一条条的机器指令的过程

## 进程与线程

### 进程

#### 概念

- 进程与程序的区别
  - 程序	
    - 静态的，就是个存放在磁盘里的可执行文件，是一系列的指令集合
  - 进程
    - 动态的，是程序的一次执行过程
    - 同一个程序多次执行会对应多个进程

#### 组成

![image-20230729201858195](./assets/image-20230729201858195.png)

- 思考：操作系统是这些进程的管理者，它们要怎么区分各个进程

- 一个进程由哪些部分组成
  - PCB：进程控制块(Process Control Block)，一个数据结构，操作系统需要对各个并发运行的进程进行管理，但凡管理时所需要的信息，都会被放在 PCB 中（**操作系统用的**）
    - PID：当进程被创建时，操作系统会为该进程分配一个唯一的、不重复的“身份证号”——PID（Process ID，进程 ID）
    - UID：进程所属用户 ID（基本的进程描述信息，可以让操作系统区分各个进程）
    - 记录给进程分配了哪些资源（如：分配了多少内存、正在使用哪些 I/O 设备、正在使用哪些文件）（可用于实现操作系统对资源的 管理）
    - 记录进程的运行情况（如：CPU 使用时间、磁盘使用情况、网络流量使用情况）（用于实现操作系统对进程的控制、调度）
  - 程序段（进程自己用的）：程序的代码（指令序列）
  - 数据段（进程自己用的）：运行过程中产生的各种数据（如：程序中定义的变量）

##### PCB

![image-20230729201914500](./assets/image-20230729201914500.png)

- 进程控制块（PCB）

  - PCB 是进程存在的唯一标志，当进程被创建时，操作系统为其创建 PCB，当进程结束时，会回收其 PCB
  - 操作系统对进程进行管理工作所需的信息都存在PCB 中
  - 进程描述信息
    - 进程标识符 PID
    - 用户标识符 UID
  - 进程控制和管理信息
    - CPU、磁盘、网络流量使用情况
    - 进程当前状态——就绪态/阻塞态/运行态
  - 资源分配清单
    - 正在使用哪些文件
    - 正在使用哪些内存区域
    - 正在使用哪些I/O设备
  - 处理机相关信息
    - 如 PSW、PC 等等各种寄存器的值（用于实现进程切换）

  ##### 程序段、数据段

![image-20230729202522577](./assets/image-20230729202522577.png)

- 进程的组成
  - PCB：给操作系统用的
  - 程序段：给自己用的，与进程自身的运行逻辑有关
    - 程序的代码（指令序列）
  - 数据段：给自己用的，与进程自身的运行逻辑有关
    - 运行过程中产生的各种数据（如：程序中定义的变量）

![image-20230729205226585](./assets/image-20230729205226585.png)

- 进程与进程实体（一般不用抠字眼）

  - 一个进程实体（进程映像）由PCB、程序段、数据段组成

  - 进程是动态的，进程实体（进程映像，某一时刻内存中进程状态的快照）是静态的

  - 进程实体反应了进程在某一时刻的状态（如：x++后，x=2）

- 引入进程实体的概念后，进程可以定义为

  - **进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位**
    - 一个进程被调度，就是指操作系统决定让这个进程上 CPU 运行
  - PCB 是进程存在的唯一标志

- 如果同时挂三个 QQ 号，会对应 3 个 QQ 进程，它们的 **PCB、数据段各不相同**，但**程序段的内容都是相同**的（都是运行着相同的 QQ程序）

#### 特征

- 进程有那些重要特征

  - 动态性（进程最基本的特征）
    - 进程是程序的一次执行过程，是动态地产生、变化和消亡

  - 并发性
    - 内存中有多个进程实体，各进程可**并发执行**
  - 独立性
    - 进程是能**独立运行**、**独立获得资源、独立接收调度的基本单位**
  - 异步性
    - 各进程按**各自独立**的、不可预支的速度向前推进
      - 异步性会导致并发程序执行结果的不确定性
    - 操作系统要提供“进程同步机制”来解决异步问题
  - 结构性
    - 每个进程都会配置一个 PCB
    - 结构上看，进程由程序段、数据段、PCB 组成

![image-20230729205242234](./assets/image-20230729205242234.png)

#### 状态与转换

![image-20230729210504819](./assets/image-20230729210504819.png)

##### 创建态

- 进程正在被创建时，它的状态是“创建态”，在这个阶段操作系统会为进程分配资源、初始化 PCB

![image-20230729210519736](./assets/image-20230729210519736.png)

##### 就绪态

- 当进程创建完成后，便进入“就绪态”
  - 处于就绪态的进程已经具备运行条件，但由于没有空闲 CPU，就暂时不能运行

- 系统中可能会有很多个进程都处于就绪态

![image-20230729210545198](./assets/image-20230729210545198.png)

##### 运行态

- 当 CPU 空闲时，操作系统就会选择一个就绪进程，让它上处理机运行
- **如果一个进程此时在 CPU 上运行**，那么这个进程处于“运行态”
  - CPU 会执行该进程对应的程序（执行指令序列）

![image-20230729210614486](./assets/image-20230729210614486.png)

##### 阻塞态

- 如果一个进程正在CPU 里运行，处于**“运行态”**
- 当运行指令：发出系统调用，请求使用打印机资源，但是打印机资源正在被其他进程占用
  - 在进程运行的过程中，可能会**请求等待某个事件的发生**（如等待某种系统资源的分配，或者等待其他进程的响应）
- 在获取所需资源之前，进程无法再往下进行，此时操作系统会让这个进程下 CPU，并让它进入**“阻塞态”**
- 当 CPU 空闲时，又会选择另一个“就绪态”进程上 CPU 运行
- 当等待的事件发生之后（如打印机空闲），之前阻塞态的进程就会重新变成就绪态，等待上 CPU 运行



![image-20230729211038502](./assets/image-20230729211038502.png)

##### 终止态

- 当一个进程运行结束以后，这个进程可以执行 exit 系统调用，请求操作系统终止该进程

- 此时该进程会进入“终止态”，操作系统会让该进程下 CPU，并回收内存空间等资源，最后还要回收该进程的 PCB
- 当终止进程的工作完成之后，这个进程就彻底消失了



##### 总结

![image-20230729212104792](./assets/image-20230729212104792.png)

- 进程开始创建：创建态
- 系统完成创建进程的一系列工作：就绪态
  - 此时除了处理机资源，其他一切资源都已经具备
- 就绪态的进程被调度：运行态
  - 此时一切资源都已经具备：处理机和其他
- 时间片到，或处理机被抢占：就绪态
- 进程用“系统调用”的方式申请某种系统资源，或者请求等待某个事件发生：阻塞态
  - 运行态 —>阻塞态是一种进程自身做出的 主动行为
- 申请的资源被分配，或者等待的事件发生：就绪态
  - 阻塞态—>就绪态不是进程自身能控制的，是一种被动行为
- 注意
  - **不能由阻塞态直接转换为运行态**
  - **不能由就绪态直接转换为阻塞态**
  - 因为进入阻塞态是进程主动请求的，必然需要进程在运行时才能发出这种请求

![image-20230729212149345](./assets/image-20230729212149345.png)

- 进程的三种基本状态：进程的整个生命周期中，大部分事件都处于这三种基本状态

  - 运行态：占用 CPU，并在 CPU 上运行
    - 单核 CPU 情况下，同一时刻只会有一个进程处于运行态，多核 CPU 可能会有多个进程处于运行态
  - 就绪态：已经具备运行条件，但由于没有空闲 CPU，而暂时不能运行
  - 阻塞态（等待态）：因等待某一事件而暂时不能运行
- 另外两种状态
  - 创建态（新建态）：进程正在被创建，操作系统为进程分配资源，初始化 PCB
  - 终止态（结束态）：进程正在从系统中撤销，操作系统会回收进程拥有的资源、撤销 PCB


- 进程 PCB 中，会有一个变量 state 来表示进程的当前状态
  - 如：1 表示创建态；2 表示就绪态；3 表示运行态
  - 为了对统一状态下的各个进程进行统一的管理，操作系统会将各个进程的 PCB 组织起来



![image-20230729213455299](./assets/image-20230729213455299.png)

#### 进程的组织

![image-20230729213013922](./assets/image-20230729213013922.png)
![image-20230729213313473](./assets/image-20230729213313473.png)

##### 链接方式（大部分）

- 三个指针
  - 执行指针：指向当前处于运行态（之形态）的进程
    - 单 CPU 计算机中，同一时刻只会有一个进程处于运行态
  - 就绪队列指针：指向当前处于就绪态的进程
    - 通常会把优先级高的进程放在队头
  - 阻塞队列指针：指向当前处于阻塞态的进程
    - 很多操作系统还会根据阻塞原因不同，再分为多个阻塞队列
      - 等待打印机的阻塞队列
      - 等待磁盘的阻塞队列

##### 索引方式

- 使用索引表

![image-20230729213420043](./assets/image-20230729213420043.png)



#### 进程控制

![image-20230729214154224](./assets/image-20230729214154224.png)

##### 主要功能

- 对系统中的所有进程实施有效的管理
- 具有创建新进程、撤销已有进程、实现进程状态转换等功能

- 简化理解：**进程控制就是要实现进程的状态转换**

##### 如何实现——原语

- 用原语实现
  - 原语是一种特殊的程序，它的**执行具有原子性**
  - 这段程序**运行必须一气呵成，不可中断**

![image-20230729214212986](./assets/image-20230729214212986.png)

- 如果不能一气呵成，就有可能导致操作系统中的某些关键数据结构信息不统一，这会映像操作系统进行别的管理工作
  - 假设此时进程 2 等待的事件发生，则操作系统中，负责进程控制的内核程序至少需要做这样两件事
    - 将 PCB 的 state 设为 1
      - 若此时收到中断信号停止，则 PCB2 中的 state=1，但是它却被放在阻塞队列里
    - 将 PCB2 从阻塞队列放到就绪队列

##### 原语如何实现原子性

![image-20230729214852272](./assets/image-20230729214852272.png)
![image-20230729215050670](./assets/image-20230729215050670.png)

- 原语的执行具有原子性，即执行过程只能一气呵成，期间不允许被中断
  - 可以用：**关中断指令**和**开中断指令**这两个**特权指令**实现原子性
- 正常情况
  - **CPU每执行完一条指令都会例行检查是否有中断信号需要处理**，如果有，则暂停运行当前这段程序，转而执行相应的中断处理程序。
  - 中断处理结束之后也不一定会直接回到原进程执行
- 关中断之后
  - CPU 不再例行检查中断信号，直到执行开中断指令之后才会恢复检查
  - 这样关中断、开中断之间的这些指令序列就是不可被中断的，这就实现了原子性
- 如果这两个特权指令允许用户程序使用的话，会发生什么情况？

##### 进程控制相关的原语

![image-20230729215456361](./assets/image-20230729215456361.png)

- 引起进程创建的原语
  - 创建原语：操作系统创建一个进程时使用的原语
    - 申请空白 PCB
    - 为新进程分配所需资源
    - 初始化 PCB
    - 将 PCB 插入就绪队列（创建态—>就绪态）
  - 引起进程创建的事件
    - 用户登录
      - 分时系统中，用户登陆成功，系统会为其建立起一个新的进程
    - 作业调度（作业：外存中没有投入运行的程序）
      - 多道批处理系统中，有新作业放入内存时，会为其建立一个新的进程
    - 提供服务
      - 用户向操作系统提出某些请求时，会新建一个进程处理该请求
    - 应用请求
      - 由用户进程主动请求创建一个子进程
  

![image-20230729215955845](./assets/image-20230729215955845.png)

- 引起进程终止的原语
  - 撤销原语：就绪态/阻塞态/运行态 —>终止态—>无
    - 从 PCB 集合中找到终止进程的 PCB
    - 若进程正在运行，立即剥夺 CPU，将 CPU 分配给其他进程
    - 终止其所有子进程：**进程间的关系是树形结构**
    - 将该进程拥有的所有资源归还给父进程或操作系统
    - 删除 PCB

  - 引起进程终止的事件
    - 正常结束：进程自己请求终止（exit 系统调用）
    - 异常结束：整数除以 0，非法使用特权指令，然后被操作系统强行杀掉
    - 外界干预：Ctrl+Alt+delete，用户选择杀掉进程


![image-20230729220717735](./assets/image-20230729220717735.png)

- 阻塞原语和唤醒原语必须成对使用

- 引起进程阻塞原语

  - 阻塞原语：运行态—>阻塞态

    - 找到要阻塞的进程对应的 PCB
    - **保护进程运行现场**，将 PCB 状态信息设置为“阻塞态”，暂时停止进程运行
    - 将 PCB 插入相应事件的等待队列
  - 引起进程阻塞的事件
    
    - 需要等待系统分配某种资源
    - 需要等待相互合作的其他进程完成工作
    
  
- 引起进程唤醒原语
  
  - 唤醒原语：阻塞态—>就绪态
  
    - 在事件等待队列中找到 PCB
    - 将 PCB 从等待队列移除，设置进程为就绪态
    - 将 PCB 插入就绪队列，等待被调度
  
  - 引起进程唤醒的事件
  
    - 等待的事件发生：因何事阻塞，就应由何事唤醒



![image-20230729222753089](./assets/image-20230729222753089.png)

- 进程切换的原语
  - 切换原语（运行态—>就绪态，就绪态—>运行态）
    - 将**运行环境信息**存入 PCB
      - 进程上下文
    - PCB移入相应队列
    - 选择另一个进程执行，并更新其 PCB
    - 根据 PCB 恢复进程所需的运行环境
  - 引起进程切换的事件
    - 当前进程事件片到
    - 有更高优先级的进程 daoda
    - 当前进程主动阻塞
    - 当前进程终止


#### 进程通信

![image-20230729224515923](./assets/image-20230729224515923.png)

##### 什么是进程间通信

- 进程间通信（IPC，Inter-Process Communication）是指两个进程之间产生数据交互

##### 为什么进程通信需要操作系统支持？

- 进程是分配系统资源的单位（包括内存地址空间），因此**各进程**拥有的**内存地址空间相互独立**
- 为了保证安全，**一个进程不能直接访问另一个进程的地址空间**

![image-20230729224936559](./assets/image-20230729224936559.png)



##### 共享存储

![image-20230730212351000](./assets/image-20230730212351000.png)

###### 基于共享存储区的共享

- 操作系统在内存中划出一块共享存储区，数据的形式、存放位置都由通信进程控制，而不是操作系统。这种共享方式速度很快，是一种高级通信方式

- 通过系统调用，申请一片共享存储区
  - 通过 mmap 系统调用，将共享内存区映射到进程自己的地址空间
  - 通过“增加页表项/段表项”即可将同一片共享内存区映射到各个进程的地址空间中

- 两个进程都可以访问这个共享存储区
  - 进程 Q 写入
  - 进程 P 读取
- 为了避免出错，各个进程对共享空间的**访问**应该是**互斥**的
- 各个进程可以使用操作系统内核提供的同步互斥工具（如 P、V 操作）
  - 避免对共享存储区的同时使用

![image-20230729225116804](./assets/image-20230729225116804.png)

###### 基于数据结构的共享

- 比如共享空间只能放一个长度为 10 的数组
- 这种共享方式速度慢、限制多，是一种低级通信方式

##### 消息传递

![image-20230730212535199](./assets/image-20230730212535199.png)

- 进程间的数据交换以**格式化的消息**（message）为单位。
  - 格式化的消息
    - 消息头
      - 发送进程 ID
      - 接收进程 ID
      - 消息长度
    - 消息体
- 进程通过操作系统提供的“发送信息/接收信息”两个**原语**进行数据交换

![image-20230730212853516](./assets/image-20230730212853516.png)

![image-20230730213304074](./assets/image-20230730213304074.png)

![image-20230730213326268](./assets/image-20230730213326268.png)

- 消息传递
  - 直接通信方式
    - 消息发送进程要指明接收进程的 ID
    - 过程
      - 进程 P 要向进程 Q 发送 msg 消息
      - 使用 发送原语 send(Q,msg) 将消息 msg 发送到操作系统内核区的进程 Q 的 PCB 的消息队列
      - 进程 Q 想要接收进程 P 发送的消息
      - 使用接受原语 receive(P,&msg) 将消息队列中 P 发送的消息msg从操作系统的内核区复制到进程 Q 的地址空间
  - 间接通信方式（信箱通信方式）
    - 通过“信箱”间接地通信，以“信箱”作为中间实体进行信息传递
    - 过程
      - 进程 P 想要向进程 Q 发送消息 msg
      - 先使用发送原语，send(A,msg)往信箱 A 发送消息 msg
      - 操作系统内核区中的信箱 A 中就有了 msg 这条消息
      - 进程 Q 想要接收信箱 A 中的消息 msg
      - 使用接收原语 send(A,&msg)从信箱中接收消息
    - 可以多个进程往同一个信箱 send 消息，也可用多个进程从同一个信箱中 receive 消息

![image-20230730214409664](./assets/image-20230730214409664.png)

![image-20230730214421570](./assets/image-20230730214421570.png)

![image-20230730214434494](./assets/image-20230730214434494.png)

##### 管道通信

- 管道是一个特殊的共享文件，又名 pipe 文件，其实就是在内存中开辟一个**大小固定的内存缓冲区**
- 管道通信 VS 共享内存的通信
  - 管道通信按顺序进行存储和读取（循环队列， FIFO）
  - 共享内存的通信可以随机位置存储和读取
- 管道通信只能采用**半双工通信**，某一时间段内只能实现单向的传输
  - 如果想要实现**双向同时通信，则需要设置两个管道**
- 各进程要**互斥**的访问管道（由操作系统实现）
- 当**管道写满**时，**写进程将阻塞**，直到读进程将管道中的数据取走，即可唤醒写进程
- 当**管道读空**时，**读进程将阻塞**，直到写进程往管道中写入数据，即可唤醒读进程
- 管道中的数据一旦被读出，就彻底消失。
  - 当多个进程读同一个管道时，可能会错乱
  - 解决方法
    - **一个管道允许多个写进程一个读进程**
    - 允许有多个写进程，多个读进程，但系统会让各个读进程轮流从管道中读数据

![image-20230730215417864](./assets/image-20230730215417864.png)

- 写进程往管道写数据，即使管道没被写满，**只要管道没空，读进程就可以从管道读数据**
- 读进程从管道读数据，即使管道没被读空，**只要管道没满，写进程就可以往管道写数据**

### 线程

![image-20230730220618058](./assets/image-20230730220618058.png)

#### 概念

##### 什么是线程，为什么要引入线程？

- 还没有引入进程之前，系统中各个程序只能串行执行
- 引入了进程后，可以进行程序的并行运行（边听歌边聊天）
- 但是进程实际上是对程序的一次执行，如果想要实现多个功能（QQ 视频、聊天、文件传输），那么没有办法执行一次就完成
  - 进程是程序的一次执行，但这些功能显然不可能是由一个程序顺序处理就能实现的
- 有的进程可能需要“同时”做很多事，而传统的**进程只能串行的执行一系列程序**
  - 因此引入线程，增加并发度
- **传统的进程是程序执行流的最小单位**
- **引入线程后，线程成为了程序执行流的最小单位**
  - 一个进程可以有多个线程
    - 两个不同的线程（QQ 视频聊天处理程序、QQ 传送文件处理程序）
    - 两个相同的线程（两个 QQ 文字聊天处理程序）
      - 线程运行的程序代码相同但是数据不相同
- 可以把线程理解为“轻量级进程”
  - 线程是一个基本的 CPU 执行单元，也是程序执行流的最小单位
  - 引入线程之后，不仅是进程之间可以并发，进程内的各线程之间也可以并发，从而提升了系统的并发度
  - 一个进程内也可以并发处理各种任务（QQ 视频、文件聊天、传文件）
- 引入线程后，进程只作为除 CPU 之外的系统资源的分配单元（如打印机、内存地址空间等都是分配给进程的）

![image-20230730220745127](./assets/image-20230730220745127.png)

![image-20230730221811371](./assets/image-20230730221811371.png)

- 资源分配、调度
  - 传统进程机制中，进程是资源分配、调度的基本单位
  - 引入线程后，**进程是资源分配的基本单位，线程是调度的基本单位**
- 并发性
  - 传统进程机制中，只能进程间并发
  - 引入线程后，各线程间也能并发，提升了并发度
- 系统开销
  - 传统的进程间并发，需要切换进程的开发环境，系统开销很大
  - **线程间并发，如果是同一进程内的线程切换，则不需要切换进程环境，系统开销小**
  - 引入线程后，**并发所带来的系统开销减少**

#### 特点
- 线程的属性
  - 线程是处理机调度的单位
  - 多 CPU 计算机中，**各个线程可占用不同的 CPU**
  - **每个线程都有一个线程 ID、线程控制块**（TCB）
  - 线程也有**就绪、阻塞、运行**三个基本状态
  - **线程几乎不拥有系统资源**
  - **同一进程的不同线程间共享进程的资源**
  - 由于共享内存地址空间，**同一进程中的线程间通信甚至无需系统干预**
  - 同一进程中的线程切换，不会引起进程切换
  - 不同进程中的线程切换，会引起进程切换
  - 切换同进程内的线程，系统开销很少
  - 切换进程，系统开销较大

![image-20230730224856355](./assets/image-20230730224856355.png)


#### 实现方式

![image-20230730224937959](./assets/image-20230730224937959.png)

![image-20230730225226976](./assets/image-20230730225226976.png)

![image-20230730225251081](./assets/image-20230730225251081.png)

![image-20230731142204793](./assets/image-20230731142204793.png)

![image-20230731142219212](./assets/image-20230731142219212.png)

- 实现方式

  - 用户级线程（ULT，User-Level Thread）（只支持进程，不支持线程）

    - 历史背景

      - 早期的操作系统只支持进程，不支持线程
      - 当时的线程是由线程库来实现的

    - 从代码角度看，线程其实就是一段代码逻辑

      - 上述三段代码逻辑上可以看做三个“线程”
      - while 循环就是一个最弱智的“线程库”
      - 线程库完成了对线程的管理工作（如调度）

    - 很多编程语言提供了强大的线程库，可以实现线程的创建、销毁、调度等功能

      - 线程的管理工作由谁来完成

        - 用户级线程由应用程序通过线程库实现，所有的线程管理工作都由应用程序负责（包括线程切换）

      - 线程切换是否需要 CPU 变态？

        - 用户级线程中，线程切换可以在用户态下即可完成，无需操作系统干预

      -  操作系统是否能意识到用户级线程的存在？

         - 在用户看来，是有多个线程。但是在操作系统内核看来，并意识不到线程的存在。
         
         - 用户级线程就是从用户视角看能看到的线程
         
       - 优缺点
      
         - 优点：用户级线程的切换在用户空间即可完成切换，不需要切换到核心态，线程管理的系统开销小，效率高
         - 缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个进程不可在多核处理机上并行运行
         
    
   - 内核级线程（Kernel-Level Thread, KLT,又称“内核支持的线程”）（由操作系统支持的线程）
     - 历史背景
       - 大多数现代操作系统都实现了内核级线程，如 Windows、Linux
     - 线程的管理工作由谁来完成？
       - 内核级线程的管理工作都由操作系统内核完成
     - 线程的切换是否需要 CPU 变态？
       - 线程调度、切换等工作都由内核负责，因此内核级线程的切换必然需要在核心态下才能完成
       
     - 操作系统是否能意识到内核级线程的存在？
       
       - 操作系统会为每个内核级线程建立相应的 TCB（Thread Control Block,线程控制块）通过 TCB 对线程进行管理、“内核级线程”就是“从操作系统内核角度看能看到的线程”
       
     - 优缺点
       
       - 优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可以在多核处理机上并行执行
       
       - 缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大



![image-20230731142649775](./assets/image-20230731142649775.png)
![image-20230731142701443](./assets/image-20230731142701443.png)



#### 多线程模型

![image-20230731143205469](./assets/image-20230731143205469.png)

![image-20230731144212943](./assets/image-20230731144212943.png)

![image-20230731144231725](./assets/image-20230731144231725.png)

- 在支持内核级线程的系统中，根据用户级线程和内核级线程的映射关系，可以划分为几种多线程模型
- 一对一模型
  - 一个用户级线程映射到一个内核级线程
  - 每个用户进程有与用户级线程同数量的内核级线程
  - 优点
    - 当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行
  - 缺点
    - 一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大
- 多对一模型
  - 多个用户级线程映射到一个内核级线程
  - 一个进程只被分配一个内核级线程
  - 优点
    - 用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高
  - 缺点
    - 当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个进程不可在多核处理机上并行运行
  - 操作系统只看得见内核级线程，因此只有**内核级线程才是处理机分配的单位**
- 多对多模型
  - n 用户及线程映射到 m 个内核级线程（n>=m）每个用户进程对应 m 个内核级进程
  - 优点
    - 克服了多对一模型并发度不高的缺点（一个阻塞全体阻塞），又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点
- 理解
  - 用户级线程是“代码逻辑”的载体
  - 内核级线程是“运行机会”的载体
  - **内核级线程才是处理机分配的单位**。
    - 例如：多核 CPU 环境下，左边的进程最多被分配两个核（因为只有两个内核级线程）
  - 一段“代码逻辑”只有获得了“运行机会”才能被 CPU 执行
    - 内核级线程中可以运行任意一个有映射关系的用户级代码，只有两个内核级线程中正在运行的代码逻辑都阻塞时，这个进程才会阻塞
  - **只有所有的内核级线程都被阻塞，这个进程才会被阻塞**

#### 线程状态与转换

![image-20230731145122938](./assets/image-20230731145122938.png)



#### 线程的组织和控制

![image-20230731145218776](./assets/image-20230731145218776.png)

- TCB（线程控制块）
  - 线程标识符TID：与 PID 类似
  - 程序计数器 PC
    - 线程目前执行到哪里
  - 其他寄存器
    - 线程运行的中间结果
  - 堆栈指针
    - 堆栈保存函数调用信息、局部变量
  - 线程运行状态
    - 运行/就绪/阻塞
  - 优先级
    - 线程调度、资源分配的参考

## 处理机调度

![image-20230731150559926](./assets/image-20230731150559926.png)

### 基本概念

- 当有一堆任务要处理，但由于资源有限，这些事情没法同时处理。
- 这就需要某种规则来决定处理这些任务的顺序，这就是调度研究的问题

### 三个层次

- 作业：一个具体的任务
- 用户向系统提交了一个作业 = 用户让操作系统启动一个程序（来处理一个具体的任务）

![image-20230731151936668](./assets/image-20230731151936668.png)

#### 高级调度

- 内存空间有限，有时无法将用户提交的作业全部放入内存
- 高级调度（作业调度）
  - 简化理解：好几个程序需要启动，到底先启动哪个
  - 按一定的原则从**外存的作业后备队列中挑选一个作业调入内存**，并创建进程
  - 每个作业只调入一次，调出一次
  - 作业调入时会建立 PCB，调出时才撤销 PCB

![image-20230731151950882](./assets/image-20230731151950882.png)

#### 低级调度

- 低级调度（进程调度/处理机调度）
  - 安装某种策略**从就绪队列中选取一个进程**，**将处理机分配给它**
  - **进程调度是操作系统中最基本的一种调度**，在一般的操作系统中都必须配置进程调度
  - 进程调度的**频率很高**，一般几十毫秒一次

![image-20230731152004854](./assets/image-20230731152004854.png)

#### 中级调度

- 内存不够时，可将某些进程的数据调出外存。等内存空闲或者进程需要运行时再重新调入内存
- 暂时调到外存等待的进程状态为**挂起状态**。被挂起的进程 PCB会被组织成**挂起队列**
- 中级调度（内存调度）——**按照某种策略决定将哪个处于挂起状态的进程重新调入内存**
  - 一个进程可能会被多次调出、调入内存，因此中级调度发生的频率要比高级调度更高



#### 进程的挂起态与七状态模型

- 暂时调到外存等待的进程状态为挂起状态（挂起态，suspend）
- 挂起态又可以进一步细分为**就绪挂起、阻塞挂起**两种状态
- 挂起 VS  阻塞
  - 相同点
    - 都是暂时不能获得 CPU 的服务
  - 不同点
    - 挂起态是将进程映像调到外存去了
    - 阻塞态下进程映像还在内存中
- 有的操作系统会把就绪挂起、阻塞挂起分为两个挂起队列，甚至会根据阻塞原因不同再把阻塞挂起进程进一步细分为多个队列

![image-20230731152237536](./assets/image-20230731152237536.png)

#### 三层调度的联系、对比

![image-20230731152523475](./assets/image-20230731152523475.png)



- 作业调度
  - 按照某种规则，从后备队列中选择合适的作业将其调入内存，并为其创建进程
  - 外存—>内存（面向作业）
  - 发生频率最低
  - 无—>创建态—>就绪态
- 内存调度
  - 按照某种规则，从挂起队列中选择合适的进程将其数据调回内存
  - 外存—>内存（面向过程）
  - 发生频率中等
  - 挂起态—>就绪态（阻塞挂起—>阻塞态）
- 进程调度
  - 安装某种规则，从就绪队列中选择一个进程为其分配处理机
  - 内存—>CPU
  - 发生频率最高
  - 就绪态—>运行态

### 调度算法的评价指标

![image-20230731153801721](./assets/image-20230731153801721.png)

#### CPU 利用率

- 指 CPU“忙碌”的时间占总时间的比例
- 利用率 = 忙碌的时间/总时间（有的题目还会要求计算某种设备的利用率）
  - EG：某计算机只支持单道程序，某个作业刚开始需要再 CPU 上运行 5 秒，再用打印机打印输出 5 秒，之后再执行 5 秒，才能够结束。在此过程中，CPU 利用率、打印机利用率分别是多少？
    - CPU 利用率 = (5+5)/(5+5+5) = 2/3
    - 打印机利用率 = 5/(5+5+5) = 1/3
  - 通常会考察多道程序并发执行的情况，可以用“甘特图”来辅助计算

![image-20230731155450341](./assets/image-20230731155450341.png)

#### 系统吞吐量

- 对于计算机来说，希望能用尽可能少的时间处理完尽可能多的作业
  - 系统吞吐量：**单位时间内完成作业的数量**
  - 系统吞吐量 = 总共完成了多少道作业 / 总共花了多少时间
    - EG：某计算机系统处理完 10 道作业，共花费 100 秒，则系统吞吐量为？
      - 10/100 = 0.1道/秒

![image-20230731155503648](./assets/image-20230731155503648.png)

#### 周转时间（对作业）

- **作业从提交到完成花了多少时间**
  - 作业与进程的概念不同
    - 作业不仅要考虑建立进程后的时间，还要加上作业在外存后备队列中等待的时间
    - 程序只有在进入内存之后才会形成进程，所以作业的时间是包括进程的所有存在时间的
- 周转时间
  - 从作业被提交给系统开始，到作业完成为止的这段时间间隔
  - 包括四个部分
    - 作业在外存后备队列上等待作业调度（高级调度）的时间
    - 进程在就绪队列上等待进程调度（低级调度）的事件
    - 进程在 CPU 上执行的时间
    - 进程等待 I/O操作完成的事件
      - 后三项在一个作业的整个处理过程中，可能发生多次
  - （作业）周转时间 = 作业完成时间 - 作业提交时间
    - 对于用户来说，更关心自己的单个作业的周转时间
  - 平均周转时间 = 各作业的周转时间之和 / 作业数
    - 对于操作系统来说，更关心系统的整体表现，因此更关心所有作业周转时间的平均值
- 思考
  - 有的作业运行时间短，有的作业运行时间长，因此在周转时间相同的情况下，运行时间不同的作业，给用户的感觉肯定是不一样的
    - 排队十分钟，运行一分钟
    - 排队一分钟，运行十分钟
    - 这两个的周转时间相同，但是感受不同

![image-20230731155525631](./assets/image-20230731155525631.png)

#### 带权周转时间

- 带权周转时间 = 作业周转时间 / 作业实际运行的事件 = （作业完成时间 - 作业提交时间）/ 作业实际运行的时间
  - 带权周转时间必然 >= 1
  - **带权周转时间与周转时间都是越小越好**
  - 对于**周转时间相同**的两个作业，**实际运行时间长**的作业在相同时间内**被服务的时间更多，带权周转时间更小，用户满意度更高**
  - 对于**实际运行时间相同**的两个作业**，周转时间短的带权周转时间更小，用户满意度更高**
- 平均带权周转时间 = 各作业带权周转时间之和 /  作业数

![image-20230731160015086](./assets/image-20230731160015086.png)

#### 等待时间

- 计算机用户希望自己的作业尽可能少的等待处理机
- 等待时间
  - 进程/作业处于等待处理机状态时间之和
  - 等待时间越长，用户满意度越低
  - 过程
    - 作业在后备队列（在外存中）**等待被服务（调度）**
    - 作业调入内存后，**建立对应的进程**。这个进程会被 CPU 服务，会被 I/O设备服务，当然也会有**等待被服务**的时候
  - 进程等待时间 VS 作业等待时间
    - 对于进程来说，等待时间就是指进程建立后**等待被服务的事件之和**，在等待 I/O完成的期间其实进程也是在被服务的，所以不计入等待时间
    - 对于作业来说，不仅要考虑建立进程后的等待时间，还要加上作业在外存后备队列中等待的时间
  - 一个作业总共需要被 CPU 服务多久，被 I/O设备服务多久一般是确定不变的
  - 因此调度算法其实只会影响作业/进程的等待时间
  - 也有“平均等待时间”来评价整体性能

![image-20230731161217498](./assets/image-20230731161217498.png)

#### 响应时间

- 对于计算机用户来说，会希望自己的提交的请求（比如通过键盘输入了一个调试命令）尽早的开始被系统服务、回应
- 相应时间
  - 指从用户提交请求到首次产生响应所用的时间

![image-20230731161342186](./assets/image-20230731161342186.png)

### 进程调度的时机

![image-20230731161510280](./assets/image-20230731161510280.png)

- 进程调度（低级调度）
  - 按照某种算法从就绪队列中选择一个进程为其分配处理机
- 需要进行进程调度与切换的情况
  - 当前运行的进程主动放弃处理机
    - 进程正常终止
    - 运行过程中发生异常而终止
    - 进程主动请求阻塞（如等待 I/O）
  - 当前运行的进程被动放弃处理机
    - 分给进程的时间片用完
    - 有更紧急的事需要处理（如 I/O中断）
    - 有更高优先级的进程进入就绪队列
- 不能进行进程调度与切换的情况
  - 在处理中断的过程中
    - 中断处理过程复杂，与硬件密切相关，很难做到在中断处理过程中进行进程切换
  - 进程在**操作系统内核程序临界区中**
  - 在原子操作过程中（原语）
    - 原子操作不可中断，要一气呵成（如之前讲过的修改 PCB 中进程状态标志，并把 PCB 放到相应队列）
- 临界资源
  - **一个时间段内只允许一个进程使用的资源**
  - 各进程需要互斥地访问临界资源
- 临界区
  - 访问临界资源的那段代码
- **内核程序的临界区**
  - 一般是用来访问某种内核数据结构的
  - 比如进程的就绪队列（由各就绪进程的 PCB 组成）
- 临界区进行进程调度与切换的过程
  - 情况一：内核程序临界区不能进行进程调度与切换
    - 当前进程在临界区并且想访问就绪队列，在访问之前就会先对就绪队列上锁
    - 如果还没有退出临界区（还没解锁）就进行进程调度，但是进程调度相关的程序也需要访问就绪队列，但此时就绪队列被锁住了，因此又无法顺利进行进程调度
    - 内核程序临界区访问的临界资源如果不尽快释放的话，极有可能影响到操作系统内核的其他管理工作。
    - 因此在访问内核程序临界区期间不能进行程序调度与切换（让当前临界区的进程尽快执行完内核程序，快点解锁）
  - 情况二：普通临界区可以进行进程调度与切换
    - 进程想要请求打印机资源，但打印机已经上锁
    - 在打印机打印完成之前，进程一直处于临界区内，临临界资源不会解锁。
    - 但打印机又是慢速设备，此时如果一直不允许进程调度的话就会导致 CPU 一直空闲
    - 普通临界区访问的临界资源不会直接影响操作系统内核的管理工作
    - 因此在访问普通临界区时可以进行调度与切换



![image-20230731163451016](./assets/image-20230731163451016.png)

![image-20230731163509188](./assets/image-20230731163509188.png)

### 调度方式

![image-20230731163624091](./assets/image-20230731163624091.png)

- 非剥夺调度方式
  - 又称非抢占方式
  - 只允许进程主动放弃处理机
  - 在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态
  - 特点
    - 实现简单，系统开销小，但是无法及时处理紧急任务，适合于早期的批处理系统
- 剥夺调度方式
  - 又称抢占方式
  - 当一个进程正在处理机上执行时，如果有一个更重要或更紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更重要紧迫的那个进程
  - 优点
    - 可以优先处理更紧急的进程，也可实现让各进程按时间片轮流执行的功能（通过时钟中断）
    - 适合于分时操作系统、实时操作系统

### 进程的切换与过程

![image-20230731165425028](./assets/image-20230731165425028.png)

- 狭义的进程调度 VS 进程切换
  - **狭义的进程调度**
    - **指的是从就绪队列中选中一个要运行的进程**
    - 这个进程可以是刚刚被暂停执行的进程，也可能是**另一个进程**，后一种情况就需要**进程切换**
  - 进程切换
    - 指的是一个进程让出处理机，由另一个进程占用处理机的过程
- 广义的进程调度包含了**选择一个进程和进程切换**两个步骤
- 进程切换的过程主要完成了
  - 对原来运行进程各种数据的**保存**
  - 对新的进程各种数据的**恢复**
    - 如：程序计数器、程序状态字、各种数据寄存器等处理机现场信息，这些信息一般保存在进程控制块
- **进程切换是有代价的**
  - 如果**过于频繁的**进行进程调度、切换，必然会使**整个系统的效率降低**
  - 使系统大部分时间都花在了进程转换上，而真正用于执行过程的事件减少



### 调度器/调度程序

![image-20230731172144398](./assets/image-20230731172144398.png)

- 就绪态—>运行态/运行态—>就绪态
  - 被调度程序选中
  - 时间片用完（不同的程序可以分配不同的时间片大小）
    - 这两个过程都由调度程序引起，调度程序决定
      - 让谁运行？——调度算法
      - 运行多长时间？——时间片大小
- 调度时机——什么事件会触发“调度程序”？
  - **创建新进程**
    - 就绪队列可能会改变，从而抢占当前运行程序的CPU
  - **进程退出**
    - 当前正在运行的程序自己终结自己，使得 CPU 空闲
  - 运行**进程阻塞**
  - **I/O中断**发生（可能唤醒某些阻塞进程）
    - 可能会使得某些进程从阻塞态回到就绪态
- 非抢占式调度策略，只有**运行进程阻塞或退出**才出发调度程序工作
- 抢占式调度策略，**每个时钟中断或 k 个时钟中断**会触发调度程序工作



![image-20230731172312946](./assets/image-20230731172312946.png)

- 不支持内核级线程的操作系统，调度程序的处理对象是进程
- 支持内核级线程的操作系统，调度程序的处理对象是内核线程

### 闲逛进程（idle）

- 调度程序永远的备胎，没有其他就绪进程中，运行闲逛进程
- 特性
  - 优先级最低，只有其他指令都执行完成之后，CPU 才会运行闲逛进程
  - 可以是0 地址指令，占一个完整的指令周期（指令周期末尾例行检查中断）
  - 能耗低

![image-20230731172713757](./assets/image-20230731172713757.png)

### 早期批处理系统的调度算法（重点）

![image-20230731172754837](./assets/image-20230731172754837.png)

- 饥饿：某进程/作业长期得不到服务

#### 先来先服务（FCFS）

![image-20230731174502388](./assets/image-20230731174502388.png)

![image-20230731173334052](./assets/image-20230731173334052.png)

- First Come First Serve

- 算法思想
  - 主要从“公平”的角度考虑
    - 类似于排队买东西
  - 按照作业/进程到达的先后顺序进行服务
- 算法规则
  - 按照到达的先后顺序调度
  - 事实上就是等待时间越久的越优先得到服务
- 用于作业/进程调度
  - 用于作业调度时，考虑的是哪个作业先到达后备队列
  - 用于进程调度时，考虑的是哪个进程先到达就绪队列
- 是否可抢占？
  - 一般是非抢占式的算法
- 优缺点
  - 优点：公平，算法实现简单
  - 缺点：
    - 排在长作业（进程）后面的短作业需要等待很长时间，带权周转时间很大，对短作业来说用户体验不好
    - 对长作业有利，对短作业不利
- 是否会导致饥饿？
  - 不会

#### 最短作业优先（SJF）

![image-20230731174529060](./assets/image-20230731174529060.png)

![image-20230731174557373](./assets/image-20230731174557373.png)

![image-20230731174612732](./assets/image-20230731174612732.png)

![image-20230731174907506](./assets/image-20230731174907506.png)

- Shortest Job First
- 算法思想
  - 追求最少的平均等待时间，最少的平均周转时间，最少的平均带权周转时间
- 算法规则
  - 最短的作业/进程优先得到服务（所谓最短，是指要求服务时间最短）
- 用于作业/进程调度
  - 既可用于作业调度，也可用户进程调度
  - 用于进程调度时称为“短进程优先（SPF, Shortest Process First）”算法
- 是否可抢占？
  - SJF 和 SPF **是非抢占式**的算法
  - 但是**最短剩余时间优先算法**（SRTN,Shortest Remaining Time Next）是**抢占式版本**
- 优缺点
  - 优点：“最短的 ”平均等待时间、平均周转时间
  - 缺点：
    - 不公平
    - **对短作业有利，对长作业不利**
    - 可能产生**饥饿**现象
    - 作业/进程的运行时间是由用户提供的，并不一定真实，不一定能做到真正的短作业优先
- 是否会导致饥饿？
  - 会
  - 如果源源不断地有短作业/进程到来，可能使长作业/进程长时间得不到服务，产生饥饿现象
  - 如果一直得不到服务，则称为饿死



- 注意
  - 如果题目中没有特别说明，所提到的“短作业/进程优先算法”默认是非抢占式的
  - 很多书上都会说“SJF 调度算法 的平均等待时间、平均周转时间”最少
    - 严格来说，这个表述是错误的、不严谨的。
    - 之前的例子表明，最短剩余时间优先算法得到的平均等待时间、平均周转时间还要更少
    - 应该加上一个条件，“在所有进程同时可运行时，采用 SJF”调度算法的平均等待时间、平均周转时间最少
    - 或者是说“在所有进程都几乎同时到达时，采用 SJF 调度算法的平均等待时间、平均周转时间最少”
      - 如果不加上述前提条件，则应该说“抢占式的短作业/进程优先调度算法（最短剩余时间优先，SRNT 算法）的平均等待时间、平均周转时间最少”
  - 虽然严格来说，SJF 的平均等待时间、平均周转时间并不一定最少，但相比于其他算法（如 FCFS），SJF 依然可以获得较少的平均等待时间、平均周转时间
  - 如果选择题里面遇到“SJF 算法的平均等待时间、平均周转时间最少”的选项，那最好判断其他选项是不是有很明显的错误，如果没有更合适的选项，那也应该选择该选项

![image-20230731174922716](./assets/image-20230731174922716.png)

#### 思考：FCFS  VS  SJF

- FCFS 算法是在每次调度的时候选择一个等待时间最长的作业（进程）为其服务
  - 但是没有考虑到作业的运行时间，因此导致了对短作业不友好的问题
- SJF 算法是选择一个执行时间最短的作业为其服务
  - 但是又完全不考虑各个作业的等待时间，因此导致了对长作业不友好的问题，甚至还会造成饥饿问题

#### 最高响应比优先（HRRN）

![image-20230731180554689](./assets/image-20230731180554689.png)

- 算法思想
  - 要综合考虑作业/进程的等待时间和要求服务的时间
- 算法规则
  - 在每次调度时先计算各个作业/进程的响应比最高的作业/进程为其服务
    - 响应比 = 等待时间 + 要求服务时间 / 要求服务时间 >= 1
- 用于作业/进程调度
  - 既可以用于作业调度，又可以用于进程调度
- 是否可抢占？
  - 非抢占式的算法
  - 只有当前运行的作业/进程主动放弃处理机（正常/异常完成，或主动阻塞）时，才需要调度
  - 调度时计算所有就绪进程的响应比，选择响应比最高的进程上处理机
- 优缺点
  - 优点
    - 综合考虑了等待时间和运行时间（要求服务时间）
    - 等待时间相同时，要求服务时间短的优先（SJF 的优点）
    - 要求服务时间相同时，等待时间长的优先（FCFS 的优点）
    - 对于长作业来说，随着等待时间越来越久，其响应比也会越来越大，从而避免了长作业饥饿的问题
- 是否会导致饥饿？
  - 不会

![image-20230731180957246](./assets/image-20230731180957246.png)

#### 总结

![image-20230731181447584](./assets/image-20230731181447584.png)

- 这几种算法主要关心对用户的公平性、平均周转时间、平均等待时间等评价系统整体性能的指标
- 但是不关心“响应时间”，也不区分任务的紧急程度
- 因此对于用户来说，**交互性很糟糕**
- 因此这三种算法一般**适合用于早期的批处理系统**



### 交互式系统的调度算法（重点）

![image-20230731190445164](./assets/image-20230731190445164.png)

#### 时间片轮转调度算法（RR）

![image-20230731190521671](./assets/image-20230731190521671.png)

- Round-Robin，RR
- 算法思想
  - 公平地、轮流地为各个进程服务，让每个进程在一定时间间隔内都可以得到响应

- 算法规则
  - 按照各进程到达就绪队列的顺序，轮流地让各个进程执行一个时间片（如 100ms）
  - 若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列队尾重新排队
    - 若 P1 下处理机，同一时刻新进程 P2 到达，某人新到达的进程先进入就绪队列
- 适用于作业调度还是进程调度？
  - 用于进程调度（只有作业放入内存建立了相应的进程后，才能被分配处理机时间片）
- 抢占式还是非抢占式？
  - 若进程未能在时间片内运行完，将被强行剥夺处理机使用权，因此时间片轮转豆豆算法属于抢占式算法
  - 由时钟装置发出时钟中断来通知 CPU 时间片已到
- 优缺点
  - 优点
    - 公平；响应快，适用于分时操作系统
  - 缺点
    - 由于高频率的进程切换，因此有一定开销
    - 不区分任务的紧急程度
- 是否会导致饥饿？
  - 不会
- 补充
  - 时间片太大或太小分别有什么影响？



- 时间片为 2

![image-20230731192218537](./assets/image-20230731192218537.png)
![image-20230731192305139](./assets/image-20230731192305139.png)
![image-20230731192320759](./assets/image-20230731192320759.png)

- 时间片为 5

![image-20230731192343151](./assets/image-20230731192343151.png)

- FCFS 先来先服务算法

![image-20230731192459980](./assets/image-20230731192459980.png)

- 如果**时间片太大**，使得每个进程都可以在一个时间片内就完成，则时间片轮转调度算法退**化为先来先服务调度算法，并且会增加进程响应时间**
- 因此时间片不能太大
  - 比如：系统中有 10 个进程在并发执行，如果时间片为 1 秒，则一个进程被响应可能需要等待 9 秒
    - 也就是说，如果用户在自己进程的时间片外通过键盘发出调试命令，可能需要等待 9 秒才能够被系统响应

- 时间片太小，因为进程调度、切换都是有时间代价的（保存、恢复运行环境），会导致进程切换过于频繁，系统会花费大量的时间来处理进程切换，从而导致实际用于进程执行的事件比例减少
- 因此时间片也不能太小
  - 一般来说，设计时间片时要让切换进程的开销占比不超过 1%

#### 优先级调度算法

![image-20230731194314759](./assets/image-20230731194314759.png)

- 算法思想
  - 随着计算机的发展，特别是实时操作系统的出现，越来越多的应用场景需要根据任务的紧急程度来决定处理顺序

- 算法规则
  - 调度时选择优先级最高的作业/进程

- 适用于作业调度还是进程调度？
  - 既可以用于作业调度，又可以用于进程调度
  - 甚至可用于 I/O调度

- 抢占式还是非抢占式？
  - 抢占式、非抢占式都有
  - 非抢占式只需在进程主动放弃处理机时进行调度即可，而抢占式还需在就绪队列变化时，检查是否会发生抢占

- 优缺点
  - 优点
    - 用优先级区分紧急程度、重要程度，适用于实时操作系统
    - 可灵活地调整对各种作业/进程的偏好程度

  - 缺点
    - 若源源不断地有高优先级进程到来，则可能导致饥饿

- 是否会导致饥饿？
  - 会




- 非抢占式的优先级调度算法

![image-20230731194850678](./assets/image-20230731194850678.png)

- 抢占式的优先级调度算法

![image-20230731194921845](./assets/image-20230731194921845.png)

- 就绪队列未必只有一个，可以按照不同优先级来组织
  - 不同优先级进入不同的队列
  - 从优先级比较高的队列开始调度运行
- 根据优先级是否可以改变，可以将优先级分为 静态优先级 和 动态优先级 两种
  - 静态优先级：创建进程时确定，之后一直不变
  - 动态优先级：创建时有一个初始值，之后会根据情况动态的调整优先级
- 如何合理地设置各类进程的优先级？
  - **系统进程的优先级高于用户进程**
  - **前台进程优先级高于后台进程**
  - **操作系统更偏好 I/O 型进程（或称 I/O繁忙型进程）**
    - I/O 设备和 CPU 可以并行工作
    - 如果优先让 I/O繁忙型进程优先运行的话，则越有可能让 I/O设备尽早的投入工作，则资源利用率、系统吞吐量都会得到提升
    - 与 I/O繁忙型进程相对的是计算型进程（或称 CPU 繁忙型进程）
- 如果采用的是动态优先级，什么时候应该调整？
  - 可以从追求公平、提升资源利用率等角度考虑
  - 如果某进程在就绪队列中等待了很长时间，则可以适当提升其优先级
  - 如果某进程占用处理机运行了很长时间，则可以适当降低其优先级
  - 如果发现一个进程频繁地进行 I/O操作，则可以适当的提升其优先级

![image-20230731205241161](./assets/image-20230731205241161.png)



#### 多级反馈队列调度算法

![image-20230731205414418](./assets/image-20230731205414418.png)

- 算法思想
  - 对其他调度算法的折中权衡

- 算法规则
  - 设置多级就绪队列，各级队列**优先级从高到低，时间片从小到大**
  - 新进程到达时**先进入第一级队列**，按 **FCFS 原则**排队等待被分配时间片，若用完时间片进程还未结束，则进程**进入下一级**队列队尾。如果此时**已经是在最下级**的队列，则**重新放回该队列队尾**
  - 只有第 k 级队列为空时，才会为 k+1 级队头的进程分配时间片
  - **被抢占处理机的进程**重新放回原队列的**队尾**

- 适用于作业调度还是进程调度？
  - 用于进程调度

- 抢占式还是非抢占式？
  - **抢占式算法**
  - 在 k 级队列的进程运行过程中，若更上级的队列（1~k-1 级）中进入了一个新进程，则由于新进程处于优先级更高的队列中，因此新队列会抢占处理机，原来运行的进程放回 k 级队列的队尾

- 优缺点
  - 对各类型进程相对公平（FCFS 的优点）
  - 每个新到达的进程都可以很快就得到响应（RR 的优点）
  - 短进程只用较少的事件就可以完成（SPF 的优点）
  - 不必实现估计进程的运行时间（避免用户作假）
  - 饥饿灵活的调整对各类进程的偏好程度，比如 CPU 密集型进程、I/O密集型进程
    - 可以将因 I/O阻塞的进程重新放回原队列，这样 I/O型进程就可以保持较高的优先级

- 是否会导致饥饿？
  - 会


![image-20230731210421459](./assets/image-20230731210421459.png)

#### 多级队列调度算法

![image-20230731211421218](./assets/image-20230731211421218.png)

- 系统中按进程类型设置多个队列，进程创建成功后插入，某个队列
- 优先级从高到低（可以划分为更多队列）
  - 系统进程：内存管理进程
  - 交互式进程：游戏、打字软件
  - 批处理进程：AI 模型训练、视频特效渲染
- 队列之间可采取固定优先级，或时间片划分
  - 固定优先级：高优先级空的时候低优先级进程才能被调度
  - 时间片划分：三个队列分配时间 50%,40%,10%
- 各队列采用不同的调度策略，如
  - 系统进程队列采用优先级调度
  - 交互式队列采用 RR
  - 批处理队列采用 FCFS

### 调度算法总结

- FCFS 算法的优点是公平
- SJF 算法的优点是能尽快处理完短作业；平均等待时间/平均周转时间等参数很优秀
- 时间片轮转调度算法可以让各个进程得到及时响应
- 优先级调度算法可以灵活地调整各种进程被服务的机会
- 多级反馈队列调度算法综合以上的所有优点

![image-20230731181244842](./assets/image-20230731181244842.png)
![image-20230731210756707](./assets/image-20230731210756707.png)

- 比起早期的批处理操作系统来说，由于计算机造价大幅降低，因此之后出现的交互式操作系统（包括分时操作系统、实时操作系统等）更注重系统的响应时间、公平性、平衡性等指标。而这几种算法恰好也能较好地满足交互式系统的需求。
- 因此这三种算法适合用于交互式系统
  - UNIX 就是使用的多级反馈队列调度算法
- 之前的三种算法则更加注重平均周转/等待时间

## 同步与互斥

![image-20230731213111129](./assets/image-20230731213111129.png)

### 进程同步的概念

![image-20230731213133921](./assets/image-20230731213133921.png)

- 异步性

  - 进程具有异步性的特征
    - 各并发执行的进程以**各自独立**的**不可预知**的速度向前推进

  - 异步性执行的顺序是不可预知的，但是有时候我们又要对执行顺序有一定的要求
    - 操作系统要提供“进程同步机制”来实现上述要求

- 进程通信——管道通信
  - 读进程和写进程并发地执行
  - 由于并发必然导致异步性，因此“写数据”和“读数据”两个操作执行的先后顺序是不确定的
  - 而实际应用中，又必须按照“写数据->读数据”的顺序来执行的
- 如何解决这种异步问题，就是进程同步所讨论的内容
- 同步
  - 直接制约关系
  - 指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而产生的制约关系
  - 进程间的直接制约关系就是源于它们之间的相互合作

### 进程互斥的概念

![image-20230731213154941](./assets/image-20230731213154941.png)

- 进程的“并发需要“共享”的支持
  - 各个并发执行的进程不可避免的需要共享一些系统资源（比如内存、打印机、摄像头这样的 I/O设备）

- 两种资源共享方式
  - 互斥共享方式
    - 系统中的某些资源，**虽然可以提供给多个进程使用，但一个时间段内只允许一个进程访问该资源**
  - 同时共享方式
    - 系统中的某些资源，**允许一个时间段内由多个进程“同时”对它们进行访问**
- 临界资源
  - **一个时间段内只允许一个进程使用的资源**
    - 许多物理设备（如摄像头、打印机）都属于临界资源
    - 许多变量、数据、内存缓冲区
  - 对临界资源的访问，必须互斥地进行

- 互斥
  - 又称间接制约关系
  - 进程互斥指当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待
  - 当前访问临界资源的进程访问结束，释放该资源之后，另一个进程才能去访问临界资源

![image-20230731214342409](./assets/image-20230731214342409.png)

- 对临界资源的互斥访问，可以在逻辑上分为如下四个部分
  - 进入区
    - entry section
    - 负责检查是否可进入临界区
    - 若可进入，则应设置**正在访问临界资源的标志**（理解为上锁），以组织其他进程同时进入临界区
  - 临界区
    - critical section
    - 访问临界资源的那段代码
  - 退出区
    - 负责解除**正在访问临界资源的标志**（可以理解为解锁）
  - 剩余区
    - remainder section
    - 做其他处理

- **临界区是进程中访问临界资源的代码段**
- **进入区和退出区是负责实现互斥地代码段**
- 临界区也可称为“临界段”
- 如果一个进程暂时不能进入临界区，那么该进程是否应该一直占着处理机？该进程又没有可能一直进入不了临界区？

![image-20230731214910017](./assets/image-20230731214910017.png)

- 为了实现对临界资源的互斥访问，同时保证系统整体性能，需要遵循以下 原则

  - 空闲让进

    - 临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区

  - 忙则等待
    - 当已有进程进入临界区时，其他试图进入临界区的进程必须等待
  
  - 优先等待
    - 对请求访问的进程，应保证能在有限时间内进入临界区（保证不会饥饿）
  
  - 让权等待
    - 当进程不能进入临界区时，应立即释放处理机，防止进程忙等待
  
- 人话：临界区空闲，可以让进程用；临界区忙/占用，其他想用的就得等；等待的时间不能太长；要等的话就赶紧先离开

### 进程互斥的软件实现办法

![image-20230731220133751](./assets/image-20230731220133751.png)

- 如果没有进程互斥
  - 进程 A、进程 B 在系统中并发地运行
    - A、B 都要使用打印机
    - 先调度 A 上处理机运行
    - 当 A 在使用打印机的过程中，分配给它的时间片用完了，接下来操作系统调度 B 让它上处理机运行
    - 进程 B 也在使用打印机
  - 结局：A、B 的打印内容混在一起了

![image-20230731220422494](./assets/image-20230731220422494.png)

#### 单标志法

![image-20230731220435016](./assets/image-20230731220435016.png)
![image-20230731221443111](./assets/image-20230731221443111.png)

- 算法思想
  - 两个进程在**访问完临界区后**会把使用临界区的权限转交给另一个进程
    - **每个进程进入临界区的权限只能被另一个进程赋予**
- 过程
  - turn 的初值为 0，即刚开始只允许 0 号进程进入临界区
  - 若 P1 先上处理机运行，则会一直卡在 5；直到 P1 的时间片用完，发生调度，切换 P0 上处理机运行
  - 代码 1 不会卡住 P0，P0 可以正常访问临界区；在 P0 访问临界区期间即使切换回 P1，P1 依然会卡在 5
  - 只有 P0 在退出区将 turn 改为 1 后，P1 才能进入临界区

- 优点
  - 该算法可以实心“同一时刻最多只允许一个进程访问临界区”

- 缺点
  - 只能按 P0->P1->P0->P1->...这样轮流访问
  - 这种必须“轮流访问”带来的问题是，如果此时允许进入临界区的进程是 P0，而 P0 一直不访问临界区，那么虽然此时临界区空闲，但是并不允许 P1 访问
  - **单标志法存在的主要问题是：违背空闲让进原则**（资源空着就让进程使用）


#### 双标志先检查

![image-20230731221720804](./assets/image-20230731221720804.png)
![image-20230731223240023](./assets/image-20230731223240023.png)

- 算法思想
  - 设置一个布尔型数组 flag[]，数组中各个元素用来**标记各进程想进入临界区的意愿**
    - “flag[0]=true”意味着 0 号进程P0 现在想要进入临界区
  - 每个进程在进入临界区之前先检查当前有没有别的进程想进入临界区
    - 如果没有，则把自身对应的标志 flag[i]设为 true，之后开始访问临界区
- 过程
  - 用 flag[]表示进入临界区意愿的数组
  - 刚开始设置为两个进程都不想进入临界区
  - 当 P1 想要进入临界区之前，检查 P0 是否想要进入临界区
    - 如果此时 P0 想要进入临界区，P1 就一直循环等待
  - 标记为 P1 进程想要进入临界区
  - 访问临界区
  - 访问完临界区，修改标记为 P1 不想使用临界区

- 缺点
  - 违反忙则等待的原则（可能会导致两个进程同时访问临界区）
- 原因
  - 进入区的“检查”和“上锁”两个处理不是一气呵成的
  - 检查后，上锁前可能发生进程切换

#### 双标志后检查

![image-20230731223354172](./assets/image-20230731223354172.png)
![image-20230731223405416](./assets/image-20230731223405416.png)

- 算法思想
  - 双标志先检查法的改版
  - 前一个算法是先检查后上锁，这两个操作又无法一气呵成，因此导致了两个进程同时进入临界区的问题
  - 因此采用先上锁后检查的方法，避免上述问题
- 过程
  - flag[]表示进入临界区意愿的数组
  - 刚开始设置两个进程都不想进入临界区
  - 标记为 P1 进程想要进入临界区
  - 如果 P0 也想进入临界区，则 P1 循环等待
  - 访问临界区
  - 访问完临界区，修改标记为 P1 不想使用临界区

- 问题
  - 虽然解决了忙则等待的问题，但是又违背了空闲让进和有限等待原则，会因各进程都长期无法访问临界资源而产生饥饿现象
  - 两个进程都争着想进入临界区，但是谁也不让谁，最后谁都无法进入临界区


#### Peterson 算法

![image-20230731224106572](./assets/image-20230731224106572.png)
![image-20230731224638219](./assets/image-20230731224638219.png)

- 算法思想

  - 结合双标志法、单标志法的思想

  - 如果双方都争着想进入临界区，那可以让进程尝试“谦让”，做一个有礼貌的进程

- 过程

  - flag[]表示进入临界区意愿的数组，初始值都是 false
  - turn 表示优先让哪个进程进入临界区
  - 先将 flag 设置为 true，表达自己想要进入临界区的意愿
  - 然后将 turn 设置为对方的值，表明自己愿意让对方先使用
  - 当（对方想要使用临界区）并且（自己愿意让给对方），就会一直循环等待
    - 主动争取
    - 主动谦让
    - 检查对方是否也想使用，且最后一次是不是自己说了客气话
  - 进入临界区使用临界资源
  - flag设置为 false，修改标记为不想使用临界区

- 优点
  - Peterson 算法用软件方法解决了进程互斥问题，遵循了空闲让进、忙 则等待、有限等待 三个原则
- 缺点
  - 但是依然未遵循让权等待的原则(自己进入不了临界区就立马释放 CPU 资源)
  - Peterson 算法相较于之前三种软件解决方案来说，是最好的，但依然不够好

### 进程互斥的硬件实现方法

![image-20230731225249973](./assets/image-20230731225249973.png)

#### 中断屏蔽方法

![image-20230801140306031](./assets/image-20230801140306031.png)

- 利用“开/关中断指令”实现

  - 与原语的实现思想相同

  - 在某进程开始访问临界区到结束访问为止都不允许被中断，也就不能发生进程切换，因此也不可能发生两个同时访问临界区的情况

  - 过程

    - 关中断后即不允许当前进程被中断，也必然不会发生进程切换

    - 直到当前进程访问完临界区，再执行开中断指令，才有可能有别的进程上处理机并访问临界区

  - 优点

    - 简单、高效

  - 缺点

    - 不适用于多处理机（关中断指令只对执行关中断的处理机有效，对其他处理机无效）
    - 只适用于操作系统内核程序，不适用于用户进程（因为开/关中断指令只能运行在内核态，这组指令如果能让用户随意使用会很危险）

#### TestAndSet（TS 指令/TSL指令）

![image-20230801140749191](./assets/image-20230801140749191.png)

- 简称 TS 指令，有地方称为 TestAndSetLock 指令，或 TSL 指令
  - TSL 指令是**用硬件实现**的，执行的过程不允许被中断，只能一气呵成
  - 双标志先检查法
- 实现方式（用代码模拟硬件）
  - 布尔型共享变量 lock 表示当前临界区是否被加锁
    - 所有进程都可以访问
    - true表示已加锁，false 表示未加锁
  - old 存放lock 原来的值
  - 返回 old 原来的值
  - 无论之前是否已经加锁，都将 lock 设为 true
- 使用 TSL 指令实现互斥的算法逻辑（使用硬件，使上锁和检查一气呵成）
  - 上锁并检查是否之前已上锁
    - lock = true 已上锁，一直执行 while 循环
    - lock = false 未上锁，进入临界区
  - 执行临界区代码段
  - 解锁 lock = false
- 若刚开始 lock 使 false，则 TSL 返回的 old 值是 false，while 循环条件不满足，直接跳过循环，进入临界区
- 若刚开始 lock 是 true，则执行 TSL 后 old 的返回值是 true，while 循环条件满足，会一直循环，直到当前访问临界区的进程在推出区进行解锁
- 相比软件实现方式
  - TSL 把上锁和检查操作用硬件的方式改变成了一气呵成的原子操作
- 优点
  - 实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞
  - 适用于多处理机环境

- 缺点
  - 不满足“让权等待”原则，暂时无法进入临界区的进程会占用 CPU 并循环执行 TSL 指令，从而导致忙等

#### Swap指令（XCHG 指令）

![image-20230801143309510](./assets/image-20230801143309510.png)

- Exchange指令
- Swap 指令也是用硬件实现的，执行的过程不允许被中断，只能一气呵成
- 实现思路
  - Swap 指令的作用是交换两个变量的值
  - lock 表示当前临界区是否被加锁，初始化为 false
  - 初始化 old 值为 true
  - 当 old == true 不断交换 old 和 lock 的值
  - 执行临界区代码段
  - 将 lock 设置为 false
- 逻辑上看Swap 和 TSL 并无太大区别，都是先记录下此时临界区是否已经被上锁（记录在 old 变量上），再将上锁标记 lock 设置为 true，最后检查 old
  - 如果 old 为 false 则说明之前没有别的进程对临界区上锁，则可跳出循环，进入临界区
- 优点
  - 实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞
  - 适用于多处理机环境
- 缺点
  - 不满足“忙则等待”原则，暂时无法进入临界区的进程会占用 CPU 并循环执行 TSL 指令，从而导致忙等



### 互斥锁

#### 概念

![image-20230801151113016](./assets/image-20230801151113016.png)

- 互斥锁
  - 解决临界区最简单的工具
  - 一个进程在进入临界区时应获得锁
    - 函数 acquire()获得锁
  - 退出临界区时释放锁
    - 函数 release()释放锁
- 每个互斥锁都有一个布尔变量 available
  - 表示锁是否可用
    - 如果锁是可用的，调用 acquire()会成功，且锁不再可用
    - 当锁不可用时，会被阻塞，直到锁释放
- acquire()或 release()的执行必须是原子操作，因此互斥通常采用硬件机制来实现
- 互斥锁的主要缺点是忙等待
  - 当有一个进程在临界区中，任何其他进程在进入临界区时必须连续循环调用 acquire()
  - 当多个进程共享同一个 CPU 时，就浪费了 CPU 周期
  - 因此**互斥锁通常用于多处理器系统**，一个线程可以在一个处理器上等待，不影响其他线程的执行
    - 自己理解
      - 一个进程a发现 available=false，没有自己想要的资源A，会一直在一个核上自娱自乐地忙等待
      - 另外的核可能正在运行着占用A资源的进程b，当这个进程用完资源 A 后，便会释放资源 A，使 available=true
      - 此时本来在自娱自乐忙等待的进程a 便会发现 available=true，便会停止忙等待，将 available=false，占用资源 A
- 需要连续循环忙等的互斥锁，都可以称为**自旋锁（spin lock）**，如 TSL 指令，Swap 指令，单标志法

![image-20230801151137051](./assets/image-20230801151137051.png)

- 特性

  - 需忙等，进程时间片用完才下处理机，违反“让权等待”
  - 优点
    - 等待期间不用切换进程上下文，多处理器系统中，若上锁的时间短，则等待代价很低
  - 常用于多处理器系统，一个核忙等，其他核照常工作，并快速释放临界区

  - 不太适用于单处理机系统，忙等的过程中不可能解锁



### 信号量机制

![image-20230801151918135](./assets/image-20230801151918135.png)

- 进程互斥的问题
  - 所有解决方案都无法实现“让权等待”
  - 在双标志先检查法中，进入区的“检查”、“上锁”操作无法一气呵成，从而导致了两个进程有可能同时进入临界区的问题

- 解决方案——信号量机制

![image-20230801152309811](./assets/image-20230801152309811.png)

- 用户进程可以通过使用操作系统提供的**一对原语**来对**信号量**进行操作，从而很方便的实现了进程互斥、进程同步
- 信号量其实就是一个变量
  - **可以是一个整数，也可以是更复杂的记录型变量**
  - 表示**系统中某种资源的数量**
    - 比如：系统中只有一台打印机，就可以设置一个初值为 1 的信号量
- 原语是一种特殊的程序段
  - **执行只能一气呵成，不可被中断**
  - 原语是由**关中断/开中断指令**实现的
  - 软件解决方案的主要问题是由“进入区的各种操作无法一气呵成”
    - 如果把进入区、退出区的操作都用“原语”实现，这些操作就能一气呵成
- 一对原语
  - wait(S)原语：P(S)
  - Signal(S)原语: V(S)
  - 可以把原语理解为我们自己写的函数，函数名分别为 wait 和 signal，括号里的信号量 S 其实就是函数调用时传入的一个参数
    - wait、signal 原语常简称为 P、V 操作（来自于荷兰语 proberen 和 verhogen）

#### 整数信号量

![image-20230801153251167](./assets/image-20230801153251167.png)

- 用一个**整数型的变量**作为信号量，用来**表示系统中某种资源的数量**
  - 与普通整数变量的区别
    - 对信号量的操作只有三种：初始化、P 操作、V 操作
- 实现过程
  - 初始化整型信号量 S，表示当前系统中可用的打印机资源数
  - wait
    - wait 原语，相当于进入区
      - 检查和上锁一气呵成，避免了并发、异步导致的问题
    - 如果资源数不够，就一直循环等待
      - 存在的问题：**不满足让权等待原则，会发生忙等**
    - 如果资源数够，就占用一个资源
  - signal
    - signal 原语，相当于“退出区”
    - 使用完资源后，在退出区释放资源
- 使用过程
  - wait(S)
    - 进入区，申请资源
  - 使用打印机资源
    - 临界区，访问资源
  - Signal(S)
    - 退出区，释放资源

#### 记录型信号量

- 为了解决整型信号量的“忙等”问题，因此又提出了“记录型信号量”，即用记录型数据结构表示的信号量

![image-20230801154624424](./assets/image-20230801154624424.png)

```C++
//记录型信号量的定义
typedef struct{
    int value;              //剩余资源数
    struct process *L;      //等待队列
} semaphore;

//某进程需要使用资源时，通过wait 原语申请
void wait(semaphore S){
    S.value--;
    if(S.value < 0){
        block(S.L);
    }
}

//进程使用完资源后，通过 signal 原语释放
void signal(semaphore S){
    S.value--;
    if(S.value <= 0){
        wakeup(S.L);
    }
}
```



- 实现过程
  - 记录型信号量的定义
    - int value：剩余资源数
    - struct process *L：等待队列
  - wait
    - 某进程需要使用资源时，通过 wait 原语申请
    - Value--
    - 如果剩余资源数不够，使用 block 原语使进程从运行态进入阻塞态
    - 并挂到信号量 S 的等待队列（即阻塞队列中）
  - signal
    - 进程使用完资源后，通过 signal 原语释放
    - value++
    - 释放完资源后，若还有别的进程在等待这种资源，则使用 wakeup 原语唤醒等待队列中的一个进程，该进程从阻塞态变为就绪态

![image-20230801165710741](./assets/image-20230801165710741.png)

- 使用过程
  - 某个计算机系统中有 2 台打印机，则初始化信号量 S 时将 S.value的值设为 2，队列 S.L设置为空
  - 申请资源 wait()
    - P0 进程申请资源，wait(), value--，此时value>0 得到资源
    - P1 进程申请资源，wait(), value--，此时 value=0 资源恰好分配完
    - P2 进程申请资源，wait(), value--，此时 value=-1<0，执行 block进入等待队列，有一个进程在等待
    - P3 进程申请资源，wait(), value--，此时 value=-2<0，执行 block进入等待队列，有两个进程在等待
  - 释放资源 signal()
    - P0使用资源完毕，signal(), value++，此时 value=-1<0说明有进程在等待队列，执行 wakeup 唤醒等待队列中的进程P2
    - P1使用资源完毕，signal(), value++，此时 value=0=0说明有进程在等待队列，执行 wakeup 唤醒等待队列中的进程P3
    - P2使用资源完毕，signal(), value++，此时 value=1>0说明没有进程在等待该资源
    - P3使用资源完毕，signal(), value++，此时 value=2>0说明没有进程在等待该资源

![image-20230801165905317](./assets/image-20230801165905317.png)

- 在考研题目中 wait(S)、signal(S)也可用记为P(S), V(S)
  - 这对原语可用于实现系统资源的“申请”和“释放”
- S.value的初值表示系统中某种资源的 数目
- **对信号量 S 的一次 P 操作意味着进程请求一个单位的该类资源**
  - 需要执行 S.value--，表示资源数-1
  - 当S.value<0时，表示该类资源已经分配完毕，因此进程应**调用 block 原语进行自我阻塞**（当前运行的进程从**运行态->阻塞态**）
  - 主动放弃处理机，并插入该类资源的等待队列 S.L
- 由此可见，该机制**遵循了“让权等待”原则**，不会出现忙等现象
- **对信号量 S 的一次 V 操作意味着进程释放一个单位的该类资源**
  - 需要执行 S.value++,表示资源数+1
  - 若加 1 后仍是 S.value<=0，表示仍有进程在等待该类资源
  - 因此应**调用 wakeup 原语唤醒等待队列中的第一个进程**（被唤醒进程从**阻塞态->就绪态**）

### 用信号量实现进程互斥、进程同步、进程的前驱

![image-20230801171654026](./assets/image-20230801171654026.png)

- 一个信号量对应一种资源
- 信号量的值 = 这种资源的剩余数量（信号量的值如果小于 0，说明此时有进程在等待这种资源）
- P(S)——申请一个资源 S，如果资源不够就阻塞等待
- V(S)——释放一个资源 S，如果有进程在等待该资源，则唤醒一个进程

#### 实现进程互斥

![image-20230801172212199](./assets/image-20230801172212199.png)

- 分析并发进程的关键活动，划定临界区
  - 如：对临界资源打印机的访问就应放在临界区
- 定义
  - 设置互斥信号量 mutex，初值为 1
  - 在进入区P(mutex)——申请资源
  - 在退出区V(mutex)——释放资源
    - 对于 P、V 操作是具有“排队阻塞”功能的，并不需要忙等
- 信号量机制实现互斥
  - semaphore mutex = 1
    - 初始化信号量
  - P(mutex)
    - 使用临界资源前需要加锁
  - 临界区代码
  - V(mutex)
    - 使用临界资源后需要解锁
- **对不同的临界资源需要设置不同的互斥信号量**
- **P、V操作必须成对出现**
  - 缺少 P(mutex)就不能保证临界资源的互斥访问
  - 缺少 V(mutex)会导致资源永不被唤醒

#### 实现进程同步

![image-20230801172930916](./assets/image-20230801172930916.png)

- 进程同步
  - 要让各并发进程按要求有序地推进
  - 比如，P1，P2 并发执行，由于存在异步性，因此二者交替推进的顺序是不固定的
    - 若 P2 的代码 4 要基于 P1 的代码 1 和代码 2 的运行结果才能执行，那么我们就必须保证代码 4 一定要在代码 2 之后才会执行
  - 进程同步问题就是让本来异步的进程相互配合，有序推进



![image-20230801172941345](./assets/image-20230801172941345.png)

- 用信号量实现进程同步（前 V 后 P）
  - 分析什么地方需要实现“同步关系”，即必须保证“**一前一后**”执行的两个操作（或两句代码）
  - 设置**同步信号量 S，初始为 0**
  - **在“前操作”之后执行 V(S)**
  - **在“后操作”之前执行 P(S)**
- 保证代码 4 一定是在代码2 之后执行
  - semaphore = 0
    - 初始化同步信号量，初始化为 0
    - 理解
      - 信号量 S 代表“某种资源”，刚开始是没有这种资源的。
      - P2 需要使用这种资源，而又只能由 P1 产生这种资源
  - 若先执行到 V(S)操作
    - 则 S++后 S=1
    - 之后当执行到 P(S)操作时，由于 S=1，表示有可用资源，会执行 S--，S 的值变回 0
    - P2 进程不会执行 block 原语，而是继续往下执行代码 4
  - 若先执行到 P(S)操作
    - 由于 S=0，S--后 S=-1
    - 此时没有可用资源，因此 P 操作中会执行 block 原语，主动请求阻塞
    - 之后当执行完代码 2，继而执行 V(S)操作，S++，使 S 变回0
    - 由于此时有进程在该信号量对应的阻塞队列中，因此会在 V 操作中执行wakeup 原语，唤醒 P2 进程
    - 这样 P2 进程就可以继续执行代码 4

#### 实现进程的前驱关系

![image-20230801174331731](./assets/image-20230801174331731.png)

- 进程 P1 有句代码 S1，P2 有句代码S2，P3 有句代码 S3....这些代码要求按如下前驱图所示的顺序来执行
  - 其实每一对前驱关系都是一个进程同步问题（需要保证一前一后的操作）
    - 要为每一对前驱关系各设置一个同步信号量
    - 在“前操作”之后对相应的同步信号量执行 V 操作
    - 在“后操作”之间对相应的同步信号量执行 P 操作

### 经典信号量同步、互斥问题

#### 生产者消费者问题

![image-20230801175958178](./assets/image-20230801175958178.png)

- 问题描述
  - 系统中有一组生产者进程和一组消费者进程，生产者进程每次生产一个产品放入缓冲区，消费者进程每次从缓冲区中取出一个产品并使用（这里的产品理解为某种数据）
    - 生产者、消费者共享一个初始为空、大小为 n 的缓冲区
    - 只有缓冲区没满时，生产者才能把产品放入缓冲区，否则必须等待
      - 缓冲区没满—>生产者生产
    - 只有缓冲区不空时，消费者才能从中取出产品，否则必须等待
      - 缓冲区没空—>消费者消费
    - 缓冲区时临界资源，各进程必须互斥地访问
      - 互斥关系

![image-20230801180431367](./assets/image-20230801180431367.png)
![image-20230801181034147](./assets/image-20230801181034147.png)

- PV 操作题目分析步骤
  - 关系分析
    - 找出题目中描述的各个过程，分析它们之间的同步、互斥关系
  - 整理思路
    - 根据各个进程的操作流程确定 P、V 操作的大致顺序
  - 设置信号量
    - 根据题目条件确定信号量初值
    - 互斥信号量初值一般为 1，同步信号量的初始值要看对应资源的初始值是多少

![image-20230801181209016](./assets/image-20230801181209016.png)

- 实现过程
  - producer
    - 生产一个产品
    - P(empty)
      - 消耗一个空闲缓冲区
    - P(mutex)
    - 把产品放入缓冲区
    - V(mutex)
      - 实现互斥
    - V(full)
      - 增加一个产品
  - consumer
    - P(full)
      - 消耗一个产品（非空缓冲区）
    - P(mutex)
    - 从缓冲区取出一个产品
    - V(mutex)
    - V(empty)
      - 增加一个空闲缓冲区
    - 使用产品

- **实现互斥是在同一进程中进行一对 PV 操作**

- **实现两进程的同步关系，是在其中一个进程中执行 P，另一个进程中执行 V**

![image-20230801200932887](./assets/image-20230801200932887.png)

- 能否改变相邻 P、V 操作的顺序？
  - 若此时缓冲区内已经放满产品，则 empty=0，full=n
    - 生产者进程执行①使 mutex 变为 0，再执行②
    - 由于已经没有空闲缓冲区，因此生产者被阻塞
    - 由于生产者阻塞，因此切换会消费者进程
    - 消费者进程执行③，由于 mutex 为 0，即生产者还没有释放对临界资源的“锁”，因此消费者也被阻塞
    - 这就造成了生产者等待消费者释放空闲缓冲区，而消费者又等待生产者释放临界区的情况
    - 生产者和消费者循环等待被对方唤醒，出现“死锁”
  - 同样的，若缓冲区中没有产品，即 full=0，empty=n
    - 按③④①顺序执行就会发生死锁
  - 因此，**实现互斥地 P 操作一定要在实现同步的 P 操作之后**
  - **V 操作不会导致进程阻塞，因此两个 V 操作顺序可以交换**
- mutex 的 P 操作放在生产之前和使用产品之后
  - 可以，但是那样会让临界区上锁的时间变得更长，不利于进程交替的使用临界资源

#### 多生产者-多消费者问题

- 关键在于理清复杂的同步关系

![image-20230801201803089](./assets/image-20230801201803089.png)

- 问题描述
  - 桌子上有一只盘子，每次只能向其中放入一个水果
  - 爸爸专向盘子中放苹果，妈妈专向盘子中放橘子
  - 儿子专等着吃盘子中的橘子，女儿专等着吃盘子中的苹果
  - 只有盘子空时，爸爸或妈妈才可向盘子中放一个苹果
  - 仅当盘子中有自己需要的水果时，儿子或女儿才可以从盘子中取出水果

![image-20230801202225186](./assets/image-20230801202225186.png)

- 关系分析
  - 找出题目中描述的各个进程，分析它们之间的同步、互斥关系
    - 互斥关系（mutex=1）
      - 对缓冲区（盘子）的访问要互斥地进行
    - 同步关系（一前一后）
      - 父亲将苹果放入盘子后，女儿才能取苹果
      - 母亲将橘子放入盘子后，儿子才能取橘子
      - 只有盘子为空时，父亲或母亲才能放入水果
        - 盘子为空这个时间可以由儿子或女儿触发，事件发生后才允许父亲或母亲放水果
- 整理思路
  - 根据各进程的操作流程确定 P、V 操作的大致顺序
    - 互斥：在临界区前后分别 PV
    - 同步：前 V 后 P
- 设置信号量
  - 设置需要的信号量，并根据题目条件确定信号量初值
    - 互斥信号量初值一般是 1，同步信号量的初始值要看对应资源的初始值是多少



- 设置互斥信号量

![image-20230801203941323](./assets/image-20230801203941323.png)

- 不设置互斥信号量

![image-20230801204002813](./assets/image-20230801204002813.png)

- 分析
  - 刚开始，儿子、女儿进程即使上处理机运行也会被阻塞
  - 如果刚开始是父亲进程先上处理机运行
    - 父亲 P(plate)，可以访问盘子
    - 母亲P(plate)，阻塞等待盘子
    - 父亲放入苹果（apple）
    - 女儿进程被唤醒，其他进程即使运行也都会阻塞，暂时不可能访问临界资源（盘子）
    - 女儿P(apple)，访问盘子，V(plate)，访问盘子，V(plate)，等待盘子的母亲进程被唤醒
    - 母亲进程访问盘子（其他进程暂时都无法进入临界区）
- 原因
  - 本题中的缓冲区大小为 1
  - 在任何时刻，orange、apple、plate 三个同步信号量中最多只有一个是 1
  - 因此在任何时刻最多只有一个进程的 P 操作不会被阻塞，并顺利地进入临界区



- 如果盘子容量为 2

![image-20230801204514944](./assets/image-20230801204514944.png)

- 分析
  - 父亲 P(plate)，可以访问盘子
  - 母亲 P(plate)，可以访问盘子
  - 父亲在往盘子里放苹果，同时母亲也可用往盘子里放橘子
    - 可能会放到缓冲区的同一个位置
  - 于是就出现了两个进程同时访问缓冲区的情况
  - 有可能导致两个进程写入缓冲区的数据相互覆盖的情况
  - 因此，如果缓冲区大小大于 1，就必须专门设置一个互斥信号量 mutex 来保证互斥访问缓冲区



![image-20230801204919432](./assets/image-20230801204919432.png)

- 分析同步问题（一前一后问题）
  - 要分析什么事件在前，什么事件在后；而不是什么进程在前，什么进程在后
  - 不能从单个进程行为的角度分析，要把“一前一后”发生的事看作是两种“事件”的前后关系
- 比如
  - 正确
    - 盘子变空—>放入水果
      - 盘子变空可能是儿子引起的，也可能是女儿引起的
      - 放水果可能是父亲放的，也可能是母亲放的
  - 错误
    - 如果盘子里装有苹果，那么一定要女儿取走苹果后父亲和母亲才能再放入水果
    - 如果盘子里装有橘子，那么一定要儿子取走橘子后父亲或母亲才能再放入水果

#### 吸烟者问题

- 解决“可以生产多个产品的单生产者”问题

![image-20230801205452683](./assets/image-20230801205452683.png)

- 问题描述
  - 假设一个系统有三个抽烟者进程和一个供应者进程
  - 每个抽烟者不停地卷烟并抽掉它
  - 但是要卷起并抽调一支烟，抽烟者需要三种材料：烟草、纸和胶水
  - 三个抽烟者中，第一个拥有烟草，第二个拥有纸，第三个拥有胶水
  - 供应者进程无限的提供三种材料，每次将两种材料放桌子上，拥有剩下那种材料的抽烟者卷一根烟并抽调它，并给供应者一个信号告诉完成了
  - 供应者就会放另外两种材料在桌子上
  - 这个过程一直重复（让三个抽烟者轮流地抽烟）

![image-20230801205836629](./assets/image-20230801205836629.png)
![image-20230801210452556](./assets/image-20230801210452556.png)

- 问题分析
  - 本质上这题也属于“生产者-消费者”问题，更详细的说应该是“可生产多种产品的单生产者-多消费者”问题
  - 关系分析
    - 同步关系
      - 桌子上有组合一——第一个抽烟者取走东西
      - 桌子上有组合二——第二个抽烟者取走东西
      - 桌子上有组合三——第三个抽烟者取走东西
      - 发出完成信号——供应者将下一个组合放到桌上
        - PV 操作——前 V后 P
  - 整理思路
  - 设置信号量
    - Offer1 = 0
    - offer2 = 0
    - offer3 = 0
    - finish = 0

![image-20230801210514949](./assets/image-20230801210514949.png)

- 如何实现

  - 缓冲区大小为 1，同一时刻，四个同步信号量中，至多有一个的值为 1

    - 所以不需要设置一个专门的互斥信号量

  - 设置信号量

    - Semaphore offer1 = 0	//桌上组合 1 的数量
    - Semaphore offer2 = 0    //桌上组合 1 的数量
    - Semaphore offer3 = 0    //桌上组合 1 的数量
    - Semaphore finish = 0     //抽烟是否完成
    - int i = 0                              //用于实现三个抽烟者轮流抽烟

  - 生产者

    - ```C++
      provider(){
          while(1){
              if(i == 0){
                  将组合一放桌上;
                  V(offer1);
              }else if(i == 1){
                  将组合二放桌上;
                  V(offer2);
              }else if(i == 2){
                  将组合三放桌上;
                  V(offer3);
              }
              i = (i+1)%3;
              P(finish);
          }
      }
      ```

  - 消费者

    - ```C++
      smoker1(){
          while(1){
              P(offer1);
              从桌上拿走组合一；卷烟；抽掉；
              V(finish);
          }
      }
      ```

    - ```C++
      smoker2(){
          while(1){
              P(offer2);
              从桌上拿走组合二；卷烟；抽掉；
              V(finish);
          }
      }
      ```

    - ```C++
      smoker3(){
          while(1){
              P(offer3);
              从桌上拿走组合三；卷烟；抽掉；
              V(finish);
          }
      }
      ```

#### 读者—写者问题

- 解决**复杂的互斥问题**提供参考
- 核心思想
  - 设置一个计数器 count 用来记录当前正在访问共享文件的读进程数
  - 可以用 count 的值来判断当前进入的进程是否是第一个/最后一个读进程
  - 从而做出不同的处理
- 对 count 变量的检查和赋值不能一气呵成会导致错误
  - 所以要用互斥信号量实现一气呵成
- 用 P(w)解决写进程饥饿问题

![image-20230801211831597](./assets/image-20230801211831597.png)

- 问题描述

  - 有读者和写者两组并发进程，共享一个文件

  - 当两个或两个以上的读进程同时访问共享数据时不会产生副作用

  - 但若某个写进程和其他进程（读进程或写进程）同时访问共享数据时则可能导致数据不一致的错误

  - 因此要求

    - 允许多个读者可以同时对文件执行读操作

    - 只允许一个写者往文件中写信息

    - 任一写者在完成写操作前不允许其他读者或写者工作

    - 写者执行写操作前，应让已有的读者和写者全部退出
- **多个读者可以同时访问共享数据**
  - 与消费者进程不同，读者进程在读数据后并不会将数据清空，并不会改变数据。
  
- **读进程与写进程不能同时共享数据**，可能会导致读出的数据不一致

- **两个写进程不能同时共享数据**，可能导致数据错误覆盖的问题

![image-20230801212716552](./assets/image-20230801212716552.png)

- 问题分析

  - 关系分析
    - 两类进程：写进程、读进程
    - 互斥关系：写进程—写进程，写进程—读进程
      - 写进程与读进程不存在互斥问题

  - 整理思路

  - 设置信号量

![image-20230801213150943](./assets/image-20230801213150943.png)

- 如何实现

  - 信号量设置

    - rw = 1；       //用于实现对共享文件的互斥访问
    - count = 0； //记录当前有几个读进程正在访问文件
    - mutex=1；  //用于保证对 count 变量的互斥访问

  - 写者

    - ```C++
      writer(){
          while(1){
              P(rw);          //写之前加锁
              写文件....
              V(rw);          //写完了解锁
          }
      }
      ```

  - 读者

    - ```C++
      reader(){
          while(1){
              P(mutex);       //各读进程互斥访问 count
              if(count == 0)  //由第一个读进程负责
                  P(rw);      //读之前“加锁”
              count++;        //访问文件的读进程+1
              V(mutex);
              读文件....
              P(mutex);       //各读进程互斥访问 count
              count--;        //访问文件的读进程数-1
              if(count==0)
                  V(rw);      //读完了“解锁”
              V(mutex);
              
          }
      }
      ```

- 问题
  - 若两个读进程并发执行，则 count=0 时两个进程也许都能满足 if 条件，都会执行 P(rw)，从而使第二个读进程阻塞的情况
- 如何解决
  - 出现上述问题的原因在于**对 count 变量的检查和赋值无法一气呵成**
  - 因此可以设置另一个互斥信号量来保证各读进程对 count 的访问是互斥的
- 潜在的问题
  - 只要有读进程还在读，写进程就要一直阻塞等待，可能饿死
  - 这种算法是读进程优先的

![image-20230801214509666](./assets/image-20230801214509666.png)

- 读写公平法

  - 信号量设置

    - ```C++
      semaphore rw = 1;       //用于实现对共享文件的互斥访问
      int count = 0;          //记录当前有几个读进程在访问文件
      semaphore mutex = 1;    //用于保证对 count 变量的互斥访问
      semaphore w = 1;        //用于实现写优先
      ```

  - 写者

    - ```C++
      writer(){
          while(1){
              P(w);
              P(rw);          //写之前加锁
              写文件....
              V(rw);          //写完了解锁
              V(w);
          }
      }
      ```

  - 读者

    - ```C++
      reader(){
          while(1){
              P(w);
              P(mutex);       //各读进程互斥访问 count
              if(count == 0)  //由第一个读进程负责
                  P(rw);      //读之前“加锁”
              count++;        //访问文件的读进程+1
              V(mutex);
              V(w);
              读文件....
              P(mutex);       //各读进程互斥访问 count
              count--;        //访问文件的读进程数-1
              if(count==0)
                  V(rw);      //读完了“解锁”
              V(mutex);
          }
      }
      ```

- 分析以下并发执行 P(w)的情况
  - 读者 1—>读者2
  - 写者 1—> 写者 2
  - 写者 1 —>读者 1
  - 读者 1—> 写者 1 —>读者 2
  - 写者 1 —>读者 1 —>写者 2

- 在这种算法中，连续进入的多个读者可以同时读文件
- 写者和其他进程不能同时访问文件
- 写者不会饥饿，但也并不是真正的写优先，而是相对公平的先来先服务的原则

#### 哲学家进餐问题

- 核心问题是**避免死锁**
  - 进程之间只存在互斥关系
  - 但是与之前接触到的互斥关系不同，每个进程都需要同时持有两个临界资源，因此就有了死锁的隐患
- 遇到一个进程需要同时持有多个临界资源的情况
  - 应该参考哲学家问题的思想，分析题中给出的进程之间是否会发生循环等待，是否会发生死锁
- 哲学家就餐问题的三个思路
  - **可以对哲学家进程施加一些限制条件，比如最多允许四个哲学家同时进餐**
  - **要求奇数号哲学家先拿左边的筷子，然后再拿右边的筷子，而偶数号哲学家刚好相反**
  - **仅当一个哲学家左右两支筷子都可用时才允许他抓起筷子**

![image-20230801220100034](./assets/image-20230801220100034.png)

- 问题描述
  - 一张圆桌上坐着五名哲学家，每两个哲学家之间的桌上摆一根筷子，桌子的中间是一碗米饭
  - 哲学家只会思考和进餐
    - 在思考时，不会影响其他人
    - 饥饿的时候，才试图拿起左右两根筷子（一根一根地拿起）
      - 如果筷子已经在别人手上，则需要等待
  - 饥饿的哲学家只有同时拿起两根筷子才可以开始进餐
  - 当进餐完毕后，放下筷子继续思考
- 问题分析
  - 关系分析
    - 系统中有 5 个哲学家进程，5 位哲学家与左右邻居对其中间筷子的访问是互斥关系
  - 整理思路
    - 这个问题中只有互斥关系，但与之前遇到的问题不同的是，每个哲学家进程需要同时持有两个临界资源才能开始吃饭
    - 如何避免临界资源分配不当造成的死锁现象，是哲学家问题的精髓
  - 信号量设置
    - Chopstick[5]={1,1,1,1,1}        //定义互斥信号量数组
    - 对哲学家按 0~4 编号
      - 哲学家左边的筷子编号为 i，右边的筷子编号为(i+1)%5

![image-20230801221809741](./assets/image-20230801221809741.png)

- 如何实现

  - 信号量设置

    - ```C++
      emophore chopstick[5]={1,1,1,1,1};
      ```

  - 哲学家

    - ```C++
      Pi(){                               //i 号哲学家的进程
          while(i){       
              P(chopstick[i]);            //拿左
              P(chopstick[(i+1)%5]);      //拿右
              吃饭....
              V(chopstick[i]);            //放左
              V(chopstick[(i+1)%5]);      //放右
              思考....
          }
      }
      ```



- 存在问题
  - 如果 5 个哲学家并发地拿起了自己左手边的筷子
    - 每位哲学家循环等待右边的人放下筷子（阻塞）
    - 发生死锁

![image-20230801223809887](./assets/image-20230801223809887.png)
![image-20230801223831209](./assets/image-20230801223831209.png)

- 如何防止死锁的发生呢？

  - **可以对哲学家进程施加一些限制条件，比如最多允许四个哲学家同时进餐**

    - 这样可以保证至少有一个哲学家可以拿到左右两只筷子

  - **要求奇数号哲学家先拿左边的筷子，然后再拿右边的筷子，而偶数号哲学家刚好相反**

    - 用这种方法可以保证如果相邻的两个奇偶号哲学家都想吃饭，那么只会有其中一个可以拿起第一只筷子，另一个会直接阻塞
    - 这就避免了占有一支后再等待另一支的情况

  - **仅当一个哲学家左右两支筷子都可用时才允许他抓起筷子**

    - 信号量设置

      - ```C++
        semaphore chopstick[5]={1,1,1,1,1};
        semaphore mutex = 1;                //互斥地取筷子
        ```

    - 哲学家

      - ```C++
        Pi(){                               //i 号哲学家的进程
            while(i){       
                P(mutex);
                P(chopstick[i]);            //拿左
                P(chopstick[(i+1)%5]);      //拿右
                P(mutex);
                吃饭....
                V(chopstick[i]);            //放左
                V(chopstick[(i+1)%5]);      //放右
                思考....
            }
        }
        ```

      ![image-20230801223911677](./assets/image-20230801223911677.png)

    - 存在问题
      
      - 即使某个哲学家两边的筷子都能用，但是却不能吃饭
      - 而且也不能保证只有两边的筷子都可以用的时候才允许哲学家拿起筷子
      
    - 准确说法
      - 各哲学家拿筷子这件事必须互斥地执行
      - 这就保证了即使一个哲学家在拿筷子拿到一半时被阻塞，也不会有别的哲学家会继续尝试拿筷子
      - 当前正在吃饭的哲学家放下筷子后，被阻塞的哲学家就可以获得等待的筷子了
      - 所以不会发生死锁



### 管程

#### 为什么引入管程？

- 信号量机制存在的问题
  - 编写程序困难、易出错（死锁）
  - 程序员编写程序时需要关注复杂的 PV 操作
- 管程
  - 一种高级的同步机制
  - 与信号量机制一样，为了实现临界资源的互斥访问

#### 定义和基本特征

![image-20230802142942345](./assets/image-20230802142942345.png)

- 管程时一种特殊的软件模块，由这些部分组成（类似于面向对象的类）
  - 局部于管程的**共享数据结构**说明
    - 数据结构（对象）
  - 对该数据结构进行操作的一组过程
    - 类里的函数
  - 对局部于管程的共享数据设置初始值的语句
    - 变量的初始化
  - 管程有一个名字
    - 类名
- 管程的基本特征
  - 局部于管程的数据只能被局部于管程的过程所访问
    - 对象的局部变量只能被对象的函数方法使用
  - 一个进程只有通过调用管程内的过程才能进入管程访问共享数据
    - 进程必须调用对象的函数才能访问局部变量的数据
  - **每次仅允许一个进程在管程内执行某个内部过程**
    - 核心，保证互斥

#### 拓展 1：用管程解决生产者消费者问题

![image-20230802144049330](./assets/image-20230802144049330.png)

- 管程定义与实现（伪代码）

```C++
monitor ProducerConsumer
    condition full, empty;      //条件变量用来实现同步（排队）
    int count = 0;              //缓冲区中的产品数

		//由编译器负责实现各进程互斥地进入管程中的过程
    void insert(Item item){     //把产品 item 放入缓冲区
        if(count == N)
            wait(full);
        count ++;
        insert_item(item);
        if(count == 1)
            signal(empty);
    }
    Item remove(){              //从缓冲区取出一个产品
        if(count == 0)
            wait(empty);
        count--;
        if(count == N-1)
            signal(full);
        return remove_item();
    }
end monitor;
```

- 生产者进程

```C++
//生存者进程
producer(){
    while(1){
        item = 生产一个产品;
        ProducerConsumer.insert(item);
    }
}
```

- 消费者进程

```C++
//消费者进程
consumer(){
    while(1){
        item = ProducerConsumer.remove();
        消费产品item;
    }
}
```

- 每次仅允许一个进程在管程内执行某个内部过程
  - 例一：两个生产者进程并发执行，依次调用了 insert 过程
    - 一开始没有任何一个进程正在访问这个管程当中的任何一个函数
    - 所以第一个生产者进程在调用 insert 函数的时候是可以顺利的执行下去的，会顺利地执行完一系列代码
    - 包括判断缓冲区是否满了，或者是否有一些消费者进程需要唤醒这系列的事情
    - 如果在第一个进程里面没有执行完 insert 这个函数相应的这一系列逻辑的时候，第二个进程也想调用 insert 函数
    - 编译器的功能会暂时阻止第二个进程进入 insert 函数
    - 就会把第二个进程阻塞在 insert 函数后面，类似于一个排队器，让他先等待
    - 等第一个进程访问完了 insert 函数之后，才会让第二个进程开始进入 insert 函数，然后执行相应的一系列逻辑
    - 所以互斥的使用某一些共享数据是由编译器负责实现的，程序员写程序的时候不再需要关心如何实现互斥
    - 只需要直接调用管程提供的一系列方法，管程本身就能够保证这是互斥地进行的
- 管程中设置条件变量和等待/唤醒操作以解决同步问题
  - full，empty
  - 例二：两个消费者进程先执行，生产者进程后执行
    - 第一个消费者进程在执行的时候，首先是调用了管程的 remove 过程
    - 此时判断缓冲区里面是否有可用的产品，由于刚开始 count 的值是 0，所以第一个消费者进程需要执行 wait(empty),等待操作
    - 于是第一个消费者进程会等待在 empty 这个条件变量相关的这个队列当中
    - 同样的第二个消费者进程开始执行 remove 函数的时候也会发现此时 count 的值是 0，所以他也需要执行等待操作
    - 同样第二个消费者进程也会插入到 等待empty这个条件变量的队列队尾
    - 随后生产者进程会执行管程的 insert 函数，它会把自己生产的产品放入到缓冲区当中
    - 并且会检查自己放入的这个产品是不是这个缓冲区当中的第一个产品
    - 如果说是第一个产品，就意味着此时有可能有其他的消费者进程正在等待产品
    - 所以接下来生产者进程在执行 insert 函数的时候也会执行一个 signal(empty) 唤醒操作
    - 用于唤醒等待在 empty 这个条件变量对应的等待队列当中的某一个进程，一般是唤醒排在队头的进程，也就是第一个消费者进程
    - 由于第一个消费者进程被唤醒之后，就可以继续往下执行
    - 首先执行 count--，让 count 的值由 1 又变回了 0
    - 然后再在自己结束离开之前，检查缓冲区是不是已经满了
    - 如果缓冲区之前已经是满了，那么有可能会有生产者进程正在等待，需要被唤醒
    - 于是生产者就会调用 signal(full)唤醒操作，用于唤醒等待在 full 这个条件变量对应的等待队列当中的某一个进程，一般是唤醒排在队头的进程，也就是第一个生产者进程
    - 最后 remove_item()函数会返回一个消费者进程想要的产品（指针）
    - 第一个消费者进程就能这样得到自己想要的 产品
  - 这两个消费者进程如何实现互斥访问？或者当缓冲区中没有产品的时候消费者进程该如何处理？
    - 这些都不用消费者进程关心，由管程负责解决

![image-20230802151203262](./assets/image-20230802151203262.png)

- 总结
  - 引入管程的目的无非就是要更方便的实现进程互斥和同步
    - 需要在管程中定义共享数据（如生产者消费者问题的缓冲区 full empty）
    - 需要再管程中定义用于访问这些共享数据的函数
      - 如生产者消费者问题中，可以定义一个函数用于将产品放入缓冲区，再定义一个函数用于从缓冲区取出产品
    - 只有通过这些特定的“入口”才能访问共享数据
    - 管程中有很多“入口”，但是每次只能开放其中一个“入口”，并且只能让一个进程或线程进入
      - 如生产者消费者问题中，各进程需要互斥地访问共享缓冲区
      - 管程的这种特性即可保证一个时间段内最多只会有一个进程在访问缓冲区
        - 这种互斥特性是由编译器负责实现的，程序员不用担心
      - 可在管程中设置条件变量及等待/唤醒操作以解决同步问题
        - 可以让一个进程或线程在条件变量上等待（此时，该进程应先释放管程的使用权，也就是让出“入口”）
        - 可以通过唤醒操作将等待在条件变量上的进程或线程唤醒
  - 程序员可以用特殊的语法定义一个管程
    - monitor PeoducerConsuer
    - end monitor
  - 其他程序员就可以使用这个管程提供的特定入口方便的使用实现进程互斥/同步
  - 自己理解
    - 其实只有两种状态
      - 等待、运行
    - 管程同一时间只能被一个进程访问
    - 有进程可以畅通无阻的直接运行完管程内定义的方法，然后美美的结束自己的运行
    - 有的进程运行到一半甚至是刚开始就因为资源被占用/资源不足然后卡壳了，只能等着，而且不能干巴巴等着，要主动让出自己对管程的使用权
      - 如果不让出去那么就会一直等待，必然不可以
    - 管程中的数据只能用管程中自己的方法访问和改变，外界对它没有影响
    - 如果想在管程中实现互斥，还是需要定义信号量一样的东西

#### 拓展 2：java 中类似于管程的问题

![image-20230802152608461](./assets/image-20230802152608461.png)

```java
static class monitor{
    private Item buffer[]=new Item[N];
    private int count = 0;

    public synchronized void insert(Iteam item){
        ...
    }
}
```

- 每次只能有一个线程进入 insert 函数，如果有多个线程同时调用 insert 函数，则后来者需要排队等待



## 死锁

![image-20230809141202373](./assets/image-20230809141202373.png)

### 什么是死锁？

![image-20230809141457114](./assets/image-20230809141457114.png)

- 哲学家进餐问题中
  - 如果五位哲学家进程并发执行，都拿起了左手边的筷子
  - 每位哲学家都在等待自己右边的人放下筷子，这些哲学家进程都因等待筷子资源而被阻塞，即发生“死锁”

![image-20230809143823330](./assets/image-20230809143823330.png)

- 死锁
  - 发生死锁
    - 每个人都占有一个资源，用时又在等待另一个人手里的资源
  - 什么是死锁？
    - 在并发环境下，**各进程因竞争资源而造成的一种相互等待对方手里的资源，导致各进程都阻塞，都无法向前推进**的现象
  - 发生死锁后若没有外力干涉，这些进程都将无法向前推进

### 进程死锁、饥饿、死循环的区别

![image-20230809151059782](./assets/image-20230809151059782.png)

- 共同点
  - 都是进程发生了某种异常的状况而无法向下推进的现象(故意设计的死循环除外)

- 死锁
  - 各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象
    - 死锁一定是“循环等待对方手里的资源”导致的，因此如果有死锁现象，那**至少有两个或两个以上的进程同时发生死锁**
    - 发生死锁的进程一定处于阻塞态
- 饥饿
  - 由于长期得不到想要的资源，某进程无法向前推进的现象
    - 比如：短进程优先（SPF）算法中，若有源源不断的短进程到来，则长进程将一直得不到处理机，从而发生长进程“饥饿”
    - **可能只有一个进程发生饥饿**
    - 发生饥饿的进程既可能是阻塞态（长期得不到需要的 I/O 设备），也可能是就绪态（长期得不到处理机）
- 死循环
  - 某进程执行过程中一直跳不出某个循环的现象
    - 有时是因为程序逻辑 bug 导致的，有时是程序员故意设计的
    - **可能只有一个进程发生死循环**
      - 死循环的进程**可以上处理机运行（可以是运行态）**，只不过无法像期待的那样顺利推进
      - 死锁和饥饿问题是由于操作系统分配资源的策略不合理导致的，而死循环是由代码逻辑的错误导致的
      - **死锁和饥饿是管理者（操作系统）的问题，死循环是被管理者的问题**

### 死锁产生的必要条件

![image-20230809151628320](./assets/image-20230809151628320.png)

- 死锁产生的必要条件
  - 产生死锁必须同时满足以下四个条件，只有其中任一条件不成立，死锁就不会发生
    - 互斥条件
      - **只有对必须互斥使用的资源的争抢才会导致死锁**
        - 如哲学家的筷子、打印机设备
      - 像扬声器、内存这样可以同时让多个进程使用的资源是不会导致死锁的
        - 因为进程不用阻塞等待这种资源
    - 不剥夺条件
      - 进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放
    - 请求和保持条件
      - 进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有
      - 此时请求进程被阻塞，但又对自己已有的资源保持不放
    - 循环等待条件
      - 存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求
  - **发生死锁时一定有循环等待，但是发生循环等待时未必死锁**
    - **循环等待是死锁的必要不充分条件**
  - 同类资源数  和  循环等待
    - 如果同类资源数大于 1，则即使有循环等待，也未必发生死锁。
    - 但**如果系统中每类资源都只有一个，那循环等待就是死锁的充分必要条件**了

### 什么时候会发生死锁

![image-20230809152533173](./assets/image-20230809152533173.png)

- 什么时候会发生死锁？
  - **对系统资源的竞争**
    - 各进程对不可剥夺的资源（如打印机）的竞争可能会引起死锁，对可剥夺的资源（CPU）的竞争不会引起死锁
  - **进程递进顺序非法**
    - 请求和释放资源的顺序不当，也同样会导致死锁
    - 例如，并发执行的进程 P1、P2 分别申请占有了资源 R1，R2，之后进程 P1 又紧接着申请资源 R2，而进程 P2 又申请资源 R1，两者会因为申请的资源被对方占有而阻塞，从而发生死锁
  - **信号量的使用不当也会造成死锁**
    - 生产者—消费者问题中，如果实现互斥的 P 操作在实现同步的 P 操作之前，就有可能导致死锁
      - 可以把互斥信号量、同步信号量也看做事一种抽象的系统资源
- 总之，对不可剥夺资源的不合理分配，可能导致死锁

### 死锁的处理策略

![image-20230809153050547](./assets/image-20230809153050547.png)

- 死锁的处理策略
  - 预防死锁
    - 破坏死锁产生的四个必要条件中的一个或几个
  - 避免死锁
    - 用某种方法防止系统进入不安全状态，从而避免死锁（银行家算法）
  - 死锁的检测和解除
    - 允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措施解除死锁

#### 预防死锁

![image-20230809153419522](./assets/image-20230809153419522.png)

- 静态策略：预防死锁
  - 死锁的产生必须满足四个必要条件，只要其中一个或者几个条件不满足，死锁就不会发生
- 动态策略：避免死锁



- 让资源能共享，不互斥
- 请求资源没有
  - 软弱：把所有之前有的都释放
  - 强硬：让操作系统把别的抢过来
- 一次性全都满足，后续不能再要了
- 

![image-20230809153559302](./assets/image-20230809153559302.png)

- 破坏互斥条件
  - 互斥条件
    - 只有对必须互斥使用的资源的争抢才会导致死锁
  - 如果把只能互斥使用的资源改造成允许共享使用，则系统不会进入死锁条件
    - 比如 SPOOLing 技术，操作系统可以采用 SPOOLing 技术把独占设备在逻辑上改造成共享设备
    - 比如用 SPOOLing 技术将打印机改造为共享设备
      - 进程 1 还没用完打印机之前，进程 2 申请使用打印机会阻塞
      - 使用了 SPOOLing 技术后，在各进程看来，自己对打印机资源的使用请求立即就被接收处理了，不需要再阻塞等待
    - 缺点
      - 并不是所有的资源都可以改造成可共享使用的资源，并且为了系统安全，很多地方还必须保护这种互斥性
      - 因此，很多时候无法破坏互斥条件

![image-20230809154124672](./assets/image-20230809154124672.png)

- 破坏不剥夺条件
  - 不剥夺条件
    - 进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放
  - 方案一
    - 当某个进程请求新的资源得不到满足时，它必须立即释放保持的所有资源，待以后需要时再重新申请
    - 即使某些资源尚未使用完，也需要主动释放，从而破坏了不可剥夺条件
  - 方案二
    - 当某个进程需要的资源被其他进程所占有的时候，可以由操作系统协助，将想要的资源强行剥夺
    - 这种方式一般需要考虑各进程的优先级
      - 比如，剥夺调度方式：就是将处理机资源强行剥夺给优先级更高的进程使用
  - 缺点
    - 实现起来比较复杂
    - 释放已获得的资源可能造成前一阶段工作的失效，因此这种方法一般只适用于易保存和恢复状态的资源，比如 CPU
    - 反复地申请和释放资源会增加系统开销，降低系统吞吐量
    - 若采用方案一，意味着只要暂时得不到某个资源，之前获得的那些资源就都需要放弃，以后再重新申请
      - 如果一直发生这样的情况，就会导致进程饥饿

![image-20230809154812454](./assets/image-20230809154812454.png)

- 破坏请求和保持条件
  - 请求和保持条件
    - 进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放
  - 可以采用静态分配方法
    - 即进程在运行前一次申请完它所需要的全部资源，在它的资源未满足前，不让它投入运行
    - 一旦投入运行后，这些资源就一直归它所有，该进程就不会再请求别的任何资源了
  - 缺点
    - 有些资源可能只需要用很短的时间，因此如果进程的整个运行期间都一直保持着所有资源，就会造成严重的资源浪费，资源利用率极低
    - 可能导致某些进程饥饿

![image-20230809155214311](./assets/image-20230809155214311.png)

- 破坏循环等待条件
  - 循环等待条件
    - 存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求
  - 可采用顺序资源分配法
    - 首先给系统中的资源编号，规定**每个进程必须按编号递增的顺序请求资源**
    - 同类资源（即编号相同的资源）一次申请完
  - 原理分析
    - 一个进程只有已占有小编号的资源时，才有资格申请更大编号的资源
    - 按此规则，已持有大编号资源的进程不可能逆向地回来请求小编号的资源，从而就不会产生循环等待的现象
  - 假设系统中共有 10 个资源，编号为 1,2，……，10
    - 在任何一个时刻，总有一个进程拥有的资源编号是最大的，那这个进程申请后的资源必然畅通无阻
    - 因此不可能出现所有进程都阻塞的死锁现象
  - 缺点
    - 不方便增加新的设备，因为可能需要重新分配所有的编号
    - **进程实际使用资源的顺序可能和编号递增顺序不一致，会导致资源浪费**
    - 必须按照规定次序申请资源，用户编程麻烦

#### 避免死锁

![image-20230809160355446](./assets/image-20230809160355446.png)

##### 什么是安全序列

![image-20230809160516805](./assets/image-20230809160516805.png)

![image-20230809160717242](./assets/image-20230809160717242.png)

##### 系统的不安全状态与死锁的联系
![image-20230809161307968](./assets/image-20230809161307968.png)

- 安全序列、不安全状态、死锁的联系
  - 例子
    - 前提：如果你借给企业的钱总数达不到企业提出的最大要求，那么不管你之前给企业借了多少钱，那些钱都拿不回来了
    - 给 B 借 30 亿是不安全的……之后手里只剩 10 亿，如果 BAT 都提出再借 20 亿的请求，那么任何一个企业的需求都得不到满足
    - 给 A 借 20 亿是安全的，因为存在 T—>B—>A这样的安全序列
  - 安全序列
    - 如果系统按照这种序列分配资源，则每个进程都能顺利完成
    - 只要能找出一个安全序列，系统就是安全状态
    - 安全序列可能有多个
  - 不安全状态
    - 如果分配了资源之后，系统中找不出任何一个安全序列，系统进入了不安全状态
    - 之后所有进程可能都无法顺利的执行下去
    - **如果有进程提前归还了一些资源，那系统也有可能重新回到安全状态**，不过我们在分配资源之前总是要考虑到最坏的情况
  - 死锁
    - 如果系统处于安全状态，就一定不会发生死锁
    - 如果系统进入了不安全状态，就**可能**发生死锁
      - 处于不安全状态未必发生死锁，但发生死锁时一定是在不安全状态
- **在资源分配之前预先判断这次分配是否会导致系统进入不安全状态，以此决定是否答应资源分配请求**
  - 这是银行家算法的核心思想


##### 银行家算法——如何避免系统进入不安全状态

![image-20230809161611930](./assets/image-20230809161611930.png)

- 银行家算法
  - 核心思想
    - 在进程提出资源申请时，先预判此时分配是否会导致系统进入不安全状态
    - 如果会进入不安全状态，就暂时不答应这次请求，让该进程先阻塞等待
  - 拓展为多种资源
    - 可以把单维的数字拓展为多维的向量
      - 比如：系统中有 5 个进程 P0~P4，3 种资源 R0~R2，初始数量为（10,5,7），则某一时刻的情况可表示如下
      - 此时总共已分配 (7, 2, 5)，还剩余 (3, 3, 2)
      - 可把最大需求、已分配的数据看作矩阵， 两矩阵相减，就可算出各进程最多还需要多少资源了

![image-20230809162056099](./assets/image-20230809162056099.png)

- 此时系统是否处于安全状态？
  - 思路：尝试找出一个安全序列…    {P1，P3，P0，P2，P4}
    - 依次检查剩余可用资源 (3, 3, 2) 是否能满足各进程的需求
    - 可满足P1需求，将 P1 加入安全序列，并更新剩余可用资源值为 (5, 3, 2)
    - 依次检查剩余可用资源 (5, 3, 2) 是否能满足剩余进程（不包括已加入安全序列的进程）的需求
    - 可满足P3需求，将 P3 加入安全序列，并更新剩余可用资源值为 (7, 4, 3)
    - 依次检查剩余可用资源 (7, 4, 3) 是否能满足剩余进程（不包括已加入安全序列的进程）的需求……
    - ……
    - 以此类推，共五次循环检查即可将5个进程都加入安全序列中，最终可得一个安全序列。该算法称为安全性算法。可以很方便地用代码实现以上流程，每一轮检查都从编号较小的进程开始检查。
  - 实际做题时可以更快速的得到安全序列

![image-20230809163221800](./assets/image-20230809163221800.png)

- 手算
  - 实际做题（手算）时可用更快速的方法找到一个安全序列：
    - 经对比发现，（3, 3, 2）可满足 P1、P3，说明无论如何，这两个进程的资源需求一定是可以依次被满足的，因此P1、P3 一定可以顺利的执行完，并归还资源。 
    - 可把 P1、P3 先加入安全序列。
    - (2, 0, 0) + (2, 1, 1) + (3, 3, 2) = (7, 4, 3)
    - 剩下的 P0、P2、P4 都可被满足。
    - 同理，这些进程都可以加入安全序列。
    - 于是，5个进程全部加入安全序列，说明此时系统处于安全状态，暂不可能发生死锁

![image-20230809164612991](./assets/image-20230809164612991.png)

- 再看一个找不到安全序列的例子： 
  - 经对比发现，（3, 3, 2）可满足 P1、P3，说明无论如何，这两个进程的资源需求一定是可以依次被满足的
  - 因此P1、P3 一定可以顺利的执行完，并归还资源。
  -  可把 P1、P3 先加入安全序列。
  - (2, 0, 0) + (2, 1, 1) + (3, 3, 2) = (7, 4, 3)
  - 剩下的 P0 需要 (8, 4, 3)，P2 需要 (6, 5, 0)，P4 需要 (4, 3, 4)
  - 任何一个进程都不能被完全满足于是，无法找到任何一个安全序列
  - 说明此时系统处于不安全状态，有可能发生死锁。

![image-20230809164739227](./assets/image-20230809164739227.png)

- 银行家算法完整步骤
  - 假设系统中有 n 个进程，m 种资源
  - 每个进程在运行前先声明对各种资源的最大需求数，则可用一个 n\*m 的矩阵（可用二维数组实现）表示所有进程对各种资源的最大需求数。
  - 不妨称为最大需求矩阵 Max，Max[i, j]=K 表示进程 Pi 最多需要 K 个资源Rj。
  - 同理，系统可以用一个 n\*m 的分配矩阵 Allocation表示对所有进程的资源分配情况。
  - Max – Allocation =Need 矩阵，表示各进程最多还需要多少各类资源。
  - 另外，还要用一个长度为m的一维数组 Available 表示当前系统中还有多少可用资源。
  - 某进程Pi向系统申请资源，可用一个长度为m的一维 数组 Requesti 表示本次申请的各种资源量。
  - 可用银行家算法预判本次分配是否会导致系统进入不安全状态：
    - ①如果 Requesti[j]≤Need[i, j] (0≤j≤m)便转向②；否则认为出错。 
      - 因为它所需要的资源数已超过 它所宣布的最大值。
    - ②如果 Requesti[j]≤Available[j] (0≤j≤m)，便转向③ ；
      - 否则表示尚无足够资源，Pi必须等待。
    - ③系统试探着把资源分配给进程Pi，并修改相应的数据（并非真的分配，修改数值只是为了做预判）：
      - Available = Available - Requesti;
        Allocation[i, j] = Allocation[i, j] + Requesti[j];
        Need[i, j] = Need[i, j] – Requesti[j]
    - ④操作系统执行安全性算法，检查此次资源分配后，系统是否处于安全状态。若安全，才正式分配；否则，恢复相应数据，让进程阻塞等待

![image-20230809165528449](./assets/image-20230809165528449.png)

- 数据结构： 

  - 长度为 m 的一维数组 Available 表示还有多少可用资源
  - n\*m 矩阵 Max 表示各进程对资源的最大需求数
  - n\*m 矩阵 Allocation 表示已经给各进程分配了多少资源
  - Max – Allocation = Need 矩阵表示各进程最多还需要多少资源
  - 用长度为 m 的一位数组 Request 表示进程此次申请的各种资源数
  
- 银行家算法步骤： 

  ①检查此次申请是否超过了之前声明的最大需求数

  ②检查此时系统剩余的可用资源是否还能满足这次请求

  ③试探着分配，更改各数据结构

  ④用安全性算法检查此次分配是否会导致系统进入不安全状态

- 安全性算法步骤：

  - 检查当前的剩余可用资源是否能满足某个进程的最大需求
- 如果可以，就把该进程加入安全序列，并把该进程持有的资源全部回收。
  - 不断重复上述过程，看最终是否能让所有进程都加入安全序列。

- 系统处于不安全状态未必死锁，但死锁时一定处于不安全状态。系统处于安全状态一定不会死锁。


#### 死锁的检测和解除

![image-20230809165844171](./assets/image-20230809165844171.png)

- 如果系统中几部采取预防死锁的措施，也不采取避免死锁的错书，系统就很可能发生死锁
  - 在这种情况下，系统提供了两种算法
    - 死锁检测算法：用于检测系统状态，以确定系统中是否发生了死锁
    - 死锁解除算法：当认定系统中已经发生了死锁，利用该算法可将系统从死锁状态中解脱出来

##### 死锁的检测

![image-20230809170125831](./assets/image-20230809170125831.png)

- 死锁的检测
  - 为了能对系统是否已发生了死锁进行检测，必须
    - 用某种数据结构来保存资源的请求和分配信息
    - 提供一种算法，利用上述信息来检测系统是否已经进入死锁状态
  - 资源分配图
    - 两种节点
      - 进程节点：对应一个进程
      - 资源节点：对应一类资源，一类资源可能有多个
    - 两种边
      - 进程节点—>资源节点：请求边
        - 表示进程想申请几个资源（每条边代表一个）
      - 资源节点—>进程节点：分配边
        - 表示已经为进程分配了几个资源（每条边代表一个）

![image-20230809170155593](./assets/image-20230809170155593.png)

- 死锁的检测
  - 如果系统中剩余的可用资源数足够满足进程的需求，那么这个进程暂时是不会阻塞的，可以顺利地执行下去。
  - 如果这个进程执行结束了把资源归还系统，就可能使某些正在等待资源的进程被激活，并顺利地执行下去。
  - 相应的，这些被激活的进程执行完了之后又会归还一些资源，这样可能又会激活另外一些阻塞的进程…
- 如果按上述过程分析，最终能消除所有边，就称这个图是**可完全简化的**。此时一定没有发生死锁（相当于能找到一个安全序列）
- 如果最终不能消除所有边，那么此时就是发生了死锁

![image-20230809170211715](./assets/image-20230809170211715.png)

- 检测死锁的算法：
  - 1）在资源分配图中，找出既不阻塞又不是孤点的进程 Pi（即找出一条有向边与它相连，且该有向边对应资源的申请数量小于等于系统中已有空闲资源数量。如下图中，R1没有空闲资源，R2有一个空闲资源。若所有的连接该进程的边均满足上述条件，则这个进程能继续运行直至完成，然后释放它所占有的所有资源）。消去它所有的请求边和分配变，使之称为孤立的结点。在下图中，P1 是满足这一条件的进程结点，于是将P1的所有边消去。
  - 2）进程 Pi 所释放的资源，可以唤醒某些因等待这些资源而阻塞的进程，原来的阻塞进程可能变为非阻塞进程。在下图中，P2 就满足这样的条件。根据 1）中的方法进行一系列简化后，若能消去途中所有的边，则称该图是可完全简化的。
- 死锁定理
  - **如果某时刻系统的资源分配图时不可完全简化的，那么此时系统死锁**

##### 死锁的解除

![image-20230809170225446](./assets/image-20230809170225446.png)

- 死锁的解除
  - 一旦检测出死锁的发生，就应该立即解除死锁
  - **不是系统中所有的进程都是死锁状态，用死锁检测算法化简资源分配图后，还连着边的那些进程就是死锁进程**
  - 解除死锁的主要方法
    - **资源剥夺法**
      - 挂起（暂时放到外存上）某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程
      - 但是应防止被挂起的进程长时间得不到资源而饥饿
    - **撤销进程法**
      - 或称终止进程法
      - 强制撤销部分、甚至全部死锁进程，并剥夺这些进程的资源
      - 优点是实现简单，缺点是所付出的代价可能会很大。
      - 有些进程可能已经运行了很长时间，已经接近结束了，一旦被终止可谓是功亏一篑，以后还要从头再来
    - **进程回退法**
      - 让一个或多个死锁进程回退到足以避免死锁的地步
      - 要求系统要记录进程的历史信息，设置还原点
  - 如何决定“对谁动手”
    - 进程优先级
    - 已执行时间
    - 还要多久完成
    - 进程已经使用了多少资源
    - 进程是交互式的还是批处理式的

























